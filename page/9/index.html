
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <title>苏有福的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content>
    <meta name="description" content>
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
</head>
</html>
<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">苏有福的博客</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            云里写诗，泥里生活，岁月里洒脱。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.484Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <p>昨天我整理了公众号历史所有和面试相关的我觉得还不错的文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485434&idx=1&sn=f6bdf19d2594bf719e149e48d1384340&chksm=cea24831f9d5c1278617d347238f65f0481f36291675f05fabb382b69ea0ff3adae7ee6e6524&token=1452779379&lang=zh_CN#rd" target="_blank" rel="noopener">整理了一些有助于你拿Offer的文章</a> 。今天分享一下最近逛Github看到了一些我觉得对于Java面试以及学习有帮助的仓库，这些仓库涉及Java核心知识点整理、Java常见面试题、算法、基础知识点比如网络和操作系统等等。</p>
<h2 id="知识点相关"><a href="#知识点相关" class="headerlink" title="知识点相关"></a>知识点相关</h2><h3 id="1-JavaGuide"><a href="#1-JavaGuide" class="headerlink" title="1.JavaGuide"></a>1.JavaGuide</h3><ul>
<li>Github地址： <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li>
<li>star: 64.0k</li>
<li>介绍: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</li>
</ul>
<h3 id="2-CS-Notes"><a href="#2-CS-Notes" class="headerlink" title="2.CS-Notes"></a>2.CS-Notes</h3><ul>
<li>Github 地址：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li>
<li>Star:  68.3k </li>
<li>介绍: 技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li>
</ul>
<h3 id="3-advanced-java"><a href="#3-advanced-java" class="headerlink" title="3. advanced-java"></a>3. advanced-java</h3><ul>
<li>Github地址：<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li>
<li>star: 23.4k</li>
<li>介绍: 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习。</li>
</ul>
<h3 id="4-JCSprout"><a href="#4-JCSprout" class="headerlink" title="4.JCSprout"></a>4.JCSprout</h3><ul>
<li>Github地址：<a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">https://github.com/crossoverJie/JCSprout</a></li>
<li>star: 21.2k</li>
<li>介绍: Java Core Sprout：处于萌芽阶段的 Java 核心知识库。</li>
</ul>
<h3 id="5-toBeTopJavaer"><a href="#5-toBeTopJavaer" class="headerlink" title="5.toBeTopJavaer"></a>5.toBeTopJavaer</h3><ul>
<li>Github地址：<a href="https://github.com/hollischuang/toBeTopJavaer" target="_blank" rel="noopener">https://github.com/hollischuang/toBeTopJavaer</a></li>
<li>star: 4.0 k</li>
<li>介绍: Java工程师成神之路。</li>
</ul>
<h3 id="6-architect-awesome"><a href="#6-architect-awesome" class="headerlink" title="6.architect-awesome"></a>6.architect-awesome</h3><ul>
<li>Github地址：<a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">https://github.com/xingshaocheng/architect-awesome</a></li>
<li>star: 34.4 k</li>
<li>介绍:后端架构师技术图谱。</li>
</ul>
<h3 id="7-technology-talk"><a href="#7-technology-talk" class="headerlink" title="7.technology-talk"></a>7.technology-talk</h3><ul>
<li>Github地址： <a href="https://github.com/aalansehaiyang/technology-talk" target="_blank" rel="noopener">https://github.com/aalansehaiyang/technology-talk</a></li>
<li>star: 6.1k</li>
<li>介绍: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识。</li>
</ul>
<h3 id="8-fullstack-tutorial"><a href="#8-fullstack-tutorial" class="headerlink" title="8.fullstack-tutorial"></a>8.fullstack-tutorial</h3><ul>
<li>Github地址： <a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener">https://github.com/frank-lam/fullstack-tutorial</a></li>
<li>star: 4.0k</li>
<li>介绍: fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试。</li>
</ul>
<h3 id="9-3y"><a href="#9-3y" class="headerlink" title="9.3y"></a>9.3y</h3><ul>
<li>Github地址：<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y</a></li>
<li>star: 1.9 k</li>
<li>介绍: Java 知识整合。</li>
</ul>
<h3 id="10-java-bible"><a href="#10-java-bible" class="headerlink" title="10.java-bible"></a>10.java-bible</h3><ul>
<li>Github地址：<a href="https://github.com/biezhi/java-bible" target="_blank" rel="noopener">https://github.com/biezhi/java-bible</a></li>
<li>star: 2.3k</li>
<li>介绍:  这里记录了一些技术摘要，部分文章来自网络，本项目的目的力求分享精品技术干货，以Java为主。</li>
</ul>
<h3 id="11-interviews"><a href="#11-interviews" class="headerlink" title="11.interviews"></a>11.interviews</h3><ul>
<li>Github地址:  <a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md" target="_blank" rel="noopener">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md</a></li>
<li>star: 35.3k</li>
<li>介绍: 软件工程技术面试个人指南（国外的一个项目，虽然有翻译版，但是不太推荐，因为很多内容并不适用于国内）。</li>
</ul>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><h3 id="1-LeetCodeAnimation"><a href="#1-LeetCodeAnimation" class="headerlink" title="1.LeetCodeAnimation"></a>1.LeetCodeAnimation</h3><ul>
<li>Github 地址： <a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation</a></li>
<li>Star:  33.4k</li>
<li>介绍: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路）。</li>
</ul>
<h3 id="2-awesome-java-leetcode"><a href="#2-awesome-java-leetcode" class="headerlink" title="2.awesome-java-leetcode"></a>2.awesome-java-leetcode</h3><ul>
<li>Github地址：<a href="https://github.com/Blankj/awesome-java-leetcode" target="_blank" rel="noopener">https://github.com/Blankj/awesome-java-leetcode</a></li>
<li>star: 6.1k</li>
<li>介绍:  LeetCode 上 Facebook 的面试题目。</li>
</ul>
<h3 id="3-leetcode"><a href="#3-leetcode" class="headerlink" title="3.leetcode"></a>3.leetcode</h3><ul>
<li>Github地址：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a></li>
<li>star: 12.0k</li>
<li>介绍:  LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。)</li>
</ul>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/程序员的简历之道/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.484Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <!-- TOC -->

<ul>
<li><a href="#程序员简历就该这样写">程序员简历就该这样写</a><ul>
<li><a href="#为什么说简历很重要">为什么说简历很重要？</a><ul>
<li><a href="#先从面试前来说">先从面试前来说</a></li>
<li><a href="#再从面试中来说">再从面试中来说</a></li>
</ul>
</li>
<li><a href="#下面这几点你必须知道">下面这几点你必须知道</a></li>
<li><a href="#必须了解的两大法则">必须了解的两大法则</a><ul>
<li><a href="#star法则situation-task-action-result">STAR法则（Situation Task Action Result）</a></li>
<li><a href="#fab-法则feature-advantage-benefit">FAB 法则（Feature Advantage Benefit）</a></li>
</ul>
</li>
<li><a href="#项目经历怎么写">项目经历怎么写？</a></li>
<li><a href="#专业技能该怎么写">专业技能该怎么写？</a></li>
<li><a href="#排版注意事项">排版注意事项</a></li>
<li><a href="#其他的一些小tips">其他的一些小tips</a></li>
<li><a href="#推荐的工具网站">推荐的工具/网站</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="程序员简历就该这样写"><a href="#程序员简历就该这样写" class="headerlink" title="程序员简历就该这样写"></a>程序员简历就该这样写</h1><p>本篇文章除了教大家用Markdown如何写一份程序员专属的简历，后面还会给大家推荐一些不错的用来写Markdown简历的软件或者网站，以及如何优雅的将Markdown格式转变为PDF格式或者其他格式。</p>
<p>推荐大家使用Markdown语法写简历，然后再将Markdown格式转换为PDF格式后进行简历投递。</p>
<p>如果你对Markdown语法不太了解的话，可以花半个小时简单看一下Markdown语法说明: <a href="http://www.markdown.cn" target="_blank" rel="noopener">http://www.markdown.cn</a> 。</p>
<h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。 在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。为什么说简历很重要呢?</p>
<h3 id="先从面试前来说"><a href="#先从面试前来说" class="headerlink" title="先从面试前来说"></a>先从面试前来说</h3><ul>
<li>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</li>
<li>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</li>
</ul>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<p>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p>
<h3 id="再从面试中来说"><a href="#再从面试中来说" class="headerlink" title="再从面试中来说"></a>再从面试中来说</h3><p>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</p>
<p>所以，首先，你要明确的一点是：<strong>你不会的东西就不要写在简历上</strong>。另外，<strong>你要考虑你该如何才能让你的亮点在简历中凸显出来</strong>，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p>
<p>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</p>
<h2 id="下面这几点你必须知道"><a href="#下面这几点你必须知道" class="headerlink" title="下面这几点你必须知道"></a>下面这几点你必须知道</h2><ol>
<li>大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</li>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</strong></li>
<li><strong>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h2 id="必须了解的两大法则"><a href="#必须了解的两大法则" class="headerlink" title="必须了解的两大法则"></a>必须了解的两大法则</h2><h3 id="STAR法则（Situation-Task-Action-Result）"><a href="#STAR法则（Situation-Task-Action-Result）" class="headerlink" title="STAR法则（Situation Task Action Result）"></a>STAR法则（Situation Task Action Result）</h3><ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<h3 id="FAB-法则（Feature-Advantage-Benefit）"><a href="#FAB-法则（Feature-Advantage-Benefit）" class="headerlink" title="FAB 法则（Feature Advantage Benefit）"></a>FAB 法则（Feature Advantage Benefit）</h3><ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<p>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</p>
<h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写(下面这部分内容摘自我的简历，大家可以根据自己的情况做一些修改和完善)：</p>
<ul>
<li>计算机网络、数据结构、算法、操作系统等课内基础知识：掌握</li>
<li>Java 基础知识：掌握</li>
<li>JVM 虚拟机（Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理）：掌握</li>
<li>高并发、高可用、高性能系统开发：掌握</li>
<li>Struts2、Spring、Hibernate、Ajax、Mybatis、JQuery ：掌握</li>
<li>SSH 整合、SSM 整合、 SOA 架构：掌握</li>
<li>Dubbo： 掌握</li>
<li>Zookeeper: 掌握</li>
<li>常见消息队列: 掌握</li>
<li>Linux：掌握</li>
<li>MySQL常见优化手段：掌握</li>
<li>Spring Boot +Spring Cloud +Docker:了解</li>
<li>Hadoop 生态相关技术中的 HDFS、Storm、MapReduce、Hive、Hbase ：了解</li>
<li>Python 基础、一些常见第三方库比如OpenCV、wxpy、wordcloud、matplotlib：熟悉</li>
</ul>
<h2 id="排版注意事项"><a href="#排版注意事项" class="headerlink" title="排版注意事项"></a>排版注意事项</h2><ol>
<li>尽量简洁，不要太花里胡哨；</li>
<li>一些技术名词不要弄错了大小写比如MySQL不要写成mysql，Java不要写成Java。这个在我看来还是比较忌讳的，所以一定要注意这个细节；</li>
<li>中文和数字英文之间加上空格的话看起来会舒服一点；</li>
</ol>
<h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<h2 id="推荐的工具-网站"><a href="#推荐的工具-网站" class="headerlink" title="推荐的工具/网站"></a>推荐的工具/网站</h2><ul>
<li>冷熊简历(MarkDown在线简历工具，可在线预览、编辑和生成PDF):<a href="http://cv.ftqq.com/" target="_blank" rel="noopener">http://cv.ftqq.com/</a></li>
<li>Typora+<a href="https://github.com/geekcompany/ResumeSample/blob/master/java.md" target="_blank" rel="noopener">Java程序员简历模板</a></li>
</ul>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/程序员的简历之道/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.484Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <p>　　身边的朋友或者公众号的粉丝很多人都向我询问过：“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学哪些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指明一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。</p>
<h3 id="Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？"><a href="#Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？" class="headerlink" title="Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？"></a>Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？</h3><p>　　我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。</p>
<p>　　首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。</p>
<p>　　企业HR肯定是更喜欢高学历的人，毕竟985、211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的呢？<br>　　<br>　　双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得了不错的成绩。<strong>一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通过其他的优势来弥补。</strong> 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：<strong>①尽量在面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。</strong></p>
<h3 id="Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？"><a href="#Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？" class="headerlink" title="Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？"></a>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？</h3><p>　　当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果你想进入大厂的话，你也可以通过自己的其他优势来弥补。</p>
<p>　　我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍弃自己本专业的一些学习时间，这是无可厚非的。</p>
<p>　　建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些知识也是一定会被问到的。另外，“一定学好数据结构与算法！一定学好数据结构与算法！一定学好数据结构与算法！”，重要的东西说3遍。</p>
<h3 id="Question3-我没有实习经历的话找工作是不是特别艰难？"><a href="#Question3-我没有实习经历的话找工作是不是特别艰难？" class="headerlink" title="Question3: 我没有实习经历的话找工作是不是特别艰难？"></a>Question3: 我没有实习经历的话找工作是不是特别艰难？</h3><p>　　没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。</p>
<p>　　如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮点，不然，你应该就会被刷。</p>
<h3 id="Question4-我该如何准备面试呢？面试的注意事项有哪些呢？"><a href="#Question4-我该如何准备面试呢？面试的注意事项有哪些呢？" class="headerlink" title="Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？"></a>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？</h3><p>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：</p>
<ol>
<li><strong>准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改</strong>（突出重点，突出自己的优势在哪里，切忌流水账）；</li>
<li><strong>注意随身带上自己的成绩单和简历复印件；</strong> （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。）</li>
<li><strong>如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。</strong>（平时空闲时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞定。</li>
<li><strong>提前准备技术面试。</strong> 搞清楚自己面试中可能涉及哪些知识点、哪些知识点是重点。面试中哪些问题会被经常问到、自己该如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>
<li><strong>面试之前做好定向复习。</strong> 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li>
<li><strong>准备好自己的项目介绍。</strong> 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图）；②在这个项目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如：用 redis 做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
<li><strong>面试之后记得复盘。</strong> 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，不要灰心；如果通过，切勿狂喜。</li>
</ol>
<p><strong>一些还算不错的 Java面试/学习相关的仓库，相信对大家准备面试一定有帮助：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484817&idx=1&sn=12f0c254a240c40c2ccab8314653216b&chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&token=766994974&lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></p>
<h3 id="Question5-我该自学还是报培训班呢？"><a href="#Question5-我该自学还是报培训班呢？" class="headerlink" title="Question5: 我该自学还是报培训班呢？"></a>Question5: 我该自学还是报培训班呢？</h3><p>　　我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。</p>
<p>　　另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。</p>
<p>　　总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。</p>
<h3 id="Question6-没有项目经历-博客-Github开源项目怎么办？"><a href="#Question6-没有项目经历-博客-Github开源项目怎么办？" class="headerlink" title="Question6: 没有项目经历/博客/Github开源项目怎么办？"></a>Question6: 没有项目经历/博客/Github开源项目怎么办？</h3><p>　　从现在开始做！</p>
<p>　　网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相关 Java 后台项目的话，你也可以主动申请参与进来。</p>
<p>　　如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内容、读书笔记等等都可以。</p>
<p>　　多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会收获一个不错的开源项目！</p>
<h3 id="Question7-大厂到底青睐什么样的应届生？"><a href="#Question7-大厂到底青睐什么样的应届生？" class="headerlink" title="Question7: 大厂到底青睐什么样的应届生？"></a>Question7: 大厂到底青睐什么样的应届生？</h3><p>　　从阿里、腾讯等大厂招聘官网对于Java后端方向/后端方向的应届实习生的要求，我们大概可以总结归纳出下面这 4 点能给简历增加很多分数：</p>
<ul>
<li>参加过竞赛（含金量超高的是ACM）；</li>
<li>对数据结构与算法非常熟练；</li>
<li>参与过实际项目（比如学校网站）；</li>
<li>参与过某个知名的开源项目或者自己的某个开源项目很不错；</li>
</ul>
<p>　　除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：</p>
<ul>
<li>熟悉Python、Shell、Perl等脚本语言；</li>
<li>熟悉 Java 优化，JVM调优；</li>
<li>熟悉 SOA 模式；</li>
<li>熟悉自己所用框架的底层知识比如Spring；</li>
<li>了解分布式一些常见的理论；</li>
<li>具备高并发开发经验；大数据开发经验等等。</li>
</ul>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/interviewPrepare/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.484Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <p>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。</p>
<!-- TOC -->

<ul>
<li><a href="#1-如何获取大厂面试机会">1 如何获取大厂面试机会？</a></li>
<li><a href="#2--面试前的准备">2  面试前的准备</a><ul>
<li><a href="#21-准备自己的自我介绍">2.1 准备自己的自我介绍</a></li>
<li><a href="#22-关于着装">2.2 关于着装</a></li>
<li><a href="#23-随身带上自己的成绩单和简历">2.3 随身带上自己的成绩单和简历</a></li>
<li><a href="#24-如果需要笔试就提前刷一些笔试题">2.4 如果需要笔试就提前刷一些笔试题</a></li>
<li><a href="#25-花时间一些逻辑题">2.5 花时间一些逻辑题</a></li>
<li><a href="#26-准备好自己的项目介绍">2.6 准备好自己的项目介绍</a></li>
<li><a href="#27-提前准备技术面试">2.7 提前准备技术面试</a></li>
<li><a href="#27-面试之前做好定向复习">2.7 面试之前做好定向复习</a></li>
</ul>
</li>
<li><a href="#3-面试之后复盘">3 面试之后复盘</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-如何获取大厂面试机会？"><a href="#1-如何获取大厂面试机会？" class="headerlink" title="1 如何获取大厂面试机会？"></a>1 如何获取大厂面试机会？</h2><p><strong>在讲如何获取大厂面试机会之前，先来给大家科普/对比一下两个校招非常常见的概念——春招和秋招。</strong></p>
<ol>
<li><strong>招聘人数</strong> ：秋招多于春招 ；</li>
<li><strong>招聘时间</strong> ： 秋招一般7月左右开始，大概一直持续到10月底。<font color="red">但是大厂（如BAT）都会早开始早结束，所以一定要把握好时间。</font>春招最佳时间为3月，次佳时间为4月，进入5月基本就不会再有春招了（金三银四）。  </li>
<li><strong>应聘难度</strong> ：秋招略大于春招；</li>
<li><strong>招聘公司：</strong>  秋招数量多，而春招数量较少，一般为秋招的补充。 </li>
</ol>
<p><strong>综上，一般来说，秋招的含金量明显是高于春招的。</strong></p>
<p><strong>下面我就说一下我自己知道的一些方法，不过应该也涵盖了大部分获取面试机会的方法。</strong></p>
<ol>
<li><strong>关注大厂官网，随时投递简历（走流程的网申）；</strong></li>
<li><strong>线下参加宣讲会，直接投递简历；</strong></li>
<li><strong>找到师兄师姐/认识的人，帮忙内推（能够让你避开网申简历筛选，笔试筛选，还是挺不错的，不过也还是需要你的简历够棒）；</strong></li>
<li><strong>博客发文被看中/Github优秀开源项目作者，大厂内部人员邀请你面试；</strong></li>
<li><strong>求职类网站投递简历（不是太推荐，适合海投）；</strong></li>
</ol>
<p>除了这些方法，我也遇到过这样的经历：有些大公司的一些部门可能暂时没招够人，然后如果你的亲戚或者朋友刚好在这个公司，而你正好又在寻求offer，那么面试机会基本上是有了，而且这种面试的难度好像一般还普遍比其他正规面试低很多。</p>
<h2 id="2-面试前的准备"><a href="#2-面试前的准备" class="headerlink" title="2  面试前的准备"></a>2  面试前的准备</h2><h3 id="2-1-准备自己的自我介绍"><a href="#2-1-准备自己的自我介绍" class="headerlink" title="2.1 准备自己的自我介绍"></a>2.1 准备自己的自我介绍</h3><p>从HR面、技术面到高管面/部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。</p>
<p>我这里简单分享一下我自己的自我介绍的一个简单的模板吧：</p>
<blockquote>
<p>面试官，您好！我叫某某。大学时间我主要利用课外时间学习某某。在校期间参与过一个某某系统的开发，另外，自己学习过程中也写过很多系统比如某某系统。在学习之余，我比较喜欢通过博客整理分享自己所学知识。我现在是某某社区的认证作者，写过某某很不错的文章。另外，我获得过某某奖,我的Github上开源的某个项目已经有多少Star了。</p>
</blockquote>
<h3 id="2-2-关于着装"><a href="#2-2-关于着装" class="headerlink" title="2.2 关于着装"></a>2.2 关于着装</h3><p>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</p>
<h3 id="2-3-随身带上自己的成绩单和简历"><a href="#2-3-随身带上自己的成绩单和简历" class="headerlink" title="2.3 随身带上自己的成绩单和简历"></a>2.3 随身带上自己的成绩单和简历</h3><p>有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。</p>
<h3 id="2-4-如果需要笔试就提前刷一些笔试题"><a href="#2-4-如果需要笔试就提前刷一些笔试题" class="headerlink" title="2.4 如果需要笔试就提前刷一些笔试题"></a>2.4 如果需要笔试就提前刷一些笔试题</h3><p>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。</p>
<h3 id="2-5-花时间一些逻辑题"><a href="#2-5-花时间一些逻辑题" class="headerlink" title="2.5 花时间一些逻辑题"></a>2.5 花时间一些逻辑题</h3><p>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。</p>
<h3 id="2-6-准备好自己的项目介绍"><a href="#2-6-准备好自己的项目介绍" class="headerlink" title="2.6 准备好自己的项目介绍"></a>2.6 准备好自己的项目介绍</h3><p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p>
<ol>
<li>对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如：用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h3 id="2-7-提前准备技术面试"><a href="#2-7-提前准备技术面试" class="headerlink" title="2.7 提前准备技术面试"></a>2.7 提前准备技术面试</h3><p>搞清楚自己面试中可能涉及哪些知识点、哪些知识点是重点。面试中哪些问题会被经常问到、自己该如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</p>
<h3 id="2-7-面试之前做好定向复习"><a href="#2-7-面试之前做好定向复习" class="headerlink" title="2.7 面试之前做好定向复习"></a>2.7 面试之前做好定向复习</h3><p>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</p>
<p>举个栗子：在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准备，我觉得 20 分钟我很大几率会完不成这项任务。</p>
<h2 id="3-面试之后复盘"><a href="#3-面试之后复盘" class="headerlink" title="3 面试之后复盘"></a>3 面试之后复盘</h2><p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/interviewPrepare/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.484Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <p>我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。这个时候很多人内心就会陷入短暂的纠结中：我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？ </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/%E6%97%A0%E5%A5%88.jpg" alt="无奈"></p>
<h3 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h3><p>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。我说这些并不代表你就可以直接对面试官说：“我没问题了。”，笔主当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。面试本身就是一个双向选择的过程，你对这个问题的回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</p>
<p>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化，我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</p>
<p>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</p>
<p>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</p>
<h3 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h3><p>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。总的来说，还是要真诚。除此之外，不要问太 Low 的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不上心，既然你不上心，为什么要要你呢）。举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：</p>
<ul>
<li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li>
<li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li>
<li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li>
<li>……</li>
</ul>
<h3 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h3><p>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</p>
<h4 id="面对HR或者其他Level比较低的面试官时"><a href="#面对HR或者其他Level比较低的面试官时" class="headerlink" title="面对HR或者其他Level比较低的面试官时"></a>面对HR或者其他Level比较低的面试官时</h4><ol>
<li><strong>能不能谈谈你作为一个公司老员工对公司的感受?</strong> (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</li>
<li><strong>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？有什么地方你觉得还不太好或者可以继续完善吗？</strong> （类似第一个问题，都是问面试官个人对于公司的看法。）</li>
<li><strong>我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</li>
<li><strong>接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</strong> （体现出你对工作比较上心，自助学习意识比较强。）</li>
<li><strong>这个岗位为什么还在招人？</strong> (岗位真实性和价值咨询)</li>
<li><strong>大概什么时候能给我回复呢？</strong> (终面的时候，如果面试官没有说的话，可以问一下)</li>
<li>……</li>
</ol>
<h4 id="面对部门领导"><a href="#面对部门领导" class="headerlink" title="面对部门领导"></a>面对部门领导</h4><ol>
<li><strong>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong> </li>
<li><strong>未来如果我要加入这个团队，你对我的期望是什么？</strong> （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</li>
<li><strong>公司对新入职的员工的培养机制是什么样的呢？</strong> （正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</li>
<li><strong>以您来看，这个岗位未来在公司内部的发展如何？</strong> (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</li>
<li><strong>团队现在面临的最大挑战是什么？</strong> (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</li>
</ol>
<h4 id="面对Level比较高的-比如总裁-老板"><a href="#面对Level比较高的-比如总裁-老板" class="headerlink" title="面对Level比较高的(比如总裁,老板)"></a>面对Level比较高的(比如总裁,老板)</h4><ol>
<li><strong>贵公司的发展目标和方向是什么？</strong> （看下公司的发展是否满足自己的期望）</li>
<li><strong>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong> （充分了解自己的优势和劣势）</li>
<li><strong>公司现在面临的最大挑战是什么？</strong></li>
</ol>
<h3 id="来个补充-顺便送个祝福给大家"><a href="#来个补充-顺便送个祝福给大家" class="headerlink" title="来个补充,顺便送个祝福给大家"></a>来个补充,顺便送个祝福给大家</h3><p>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯定是觉得你就是他们要招的人。</p>
<p>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。上面提到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！</p>
<p>金三银四。过了二月就到了面试高峰期或者说是黄金期。几份惊喜几份愁，愿各位能始终不忘初心！每个人都有每个人的难处。引用一句《阿甘正传》里面的台词：“生活就像一盒巧克力，你永远不知道下一块是什么味道“。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/%E7%94%9F%E6%B4%BB%E5%B0%B1%E5%83%8F%E4%B8%80%E7%9B%92%E5%B7%A7%E5%85%8B%E5%8A%9B%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%8B%E4%B8%80%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%B3%E9%81%93.JPEG" alt="加油！彩虹就要来了"></p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第四周(2018-8-30)/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.476Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <h2 id="1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？"><a href="#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？" class="headerlink" title="1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>
<ul>
<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>
<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>
</ul>
<h2 id="2-线程有哪些基本状态？这些状态是如何定义的"><a href="#2-线程有哪些基本状态？这些状态是如何定义的" class="headerlink" title="2. 线程有哪些基本状态？这些状态是如何定义的?"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="3-何为多线程？"><a href="#3-何为多线程？" class="headerlink" title="3. 何为多线程？"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>
<h2 id="4-为什么要使用多线程"><a href="#4-为什么要使用多线程" class="headerlink" title="4. 为什么要使用多线程?"></a>4. 为什么要使用多线程?</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。    </li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。<h2 id="5-使用多线程常见的三种方式"><a href="#5-使用多线程常见的三种方式" class="headerlink" title="5 使用多线程常见的三种方式"></a>5 使用多线程常见的三种方式</h2></li>
</ul>
<h3 id="①继承Thread类"><a href="#①继承Thread类" class="headerlink" title="①继承Thread类"></a>①继承Thread类</h3><p>MyThread.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Run.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mythread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		mythread.start();</span><br><span class="line">		System.out.println(<span class="string">"运行结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380" alt="结果"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>
<h3 id="②实现Runnable接口"><a href="#②实现Runnable接口" class="headerlink" title="②实现Runnable接口"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>
<p>MyRunnable.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"MyRunnable"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Run.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable runnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">		Thread thread=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">		thread.start();</span><br><span class="line">		System.out.println(<span class="string">"运行结束！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316" alt="运行结果"></p>
<h3 id="③使用线程池"><a href="#③使用线程池" class="headerlink" title="③使用线程池"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>
</blockquote>
<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>
</ul>
</blockquote>
<p>对于线程池感兴趣的可以查看我的这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd" target="_blank" rel="noopener">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>
<h2 id="6-线程的优先级"><a href="#6-线程的优先级" class="headerlink" title="6 线程的优先级"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>
<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>
<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>
<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>
<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>
<h2 id="7-Java多线程分类"><a href="#7-Java多线程分类" class="headerlink" title="7 Java多线程分类"></a>7 Java多线程分类</h2><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>
<ul>
<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>
<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>
<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>
</ul>
<p><strong>如何设置守护线程？</strong></p>
<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>
<p>注意事项：</p>
<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常
2. 在守护线程中产生的新线程也是守护线程
3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</code></pre><h2 id="8-sleep-方法和wait-方法简单对比"><a href="#8-sleep-方法和wait-方法简单对比" class="headerlink" title="8 sleep()方法和wait()方法简单对比"></a>8 sleep()方法和wait()方法简单对比</h2><ul>
<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>
<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>
</ul>
<h2 id="9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第四周(2018-8-30)/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第二周(2018-8-13)/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.476Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <h3 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id="String和StringBuffer、StringBuilder的区别"><a href="#String和StringBuffer、StringBuilder的区别" class="headerlink" title="String和StringBuffer、StringBuilder的区别"></a>String和StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong>
　</p>
<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<p>AbstractStringBuilder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。
　　</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong> </p>
<ol>
<li>操作少量的数据 = String</li>
<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>
</ol>
<h4 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p>
<p><strong>1) String不可变但不代表引用不可以变</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">str = str + <span class="string">" World"</span>;</span><br><span class="line">System.out.println(<span class="string">"str="</span> + str);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=Hello World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h3 id="什么是反射机制？反射机制的应用场景有哪些？"><a href="#什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="什么是反射机制？反射机制的应用场景有哪些？"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<h4 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h4><ul>
<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>
</ul>
<h4 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h4><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h4 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h4><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br> 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">Reflection：Java反射机制的应用场景</a></li>
<li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java基础之—反射（非常重要）</a><h3 id="什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别"><a href="#什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别" class="headerlink" title="什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别"></a>什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别</h3></li>
</ul>
<p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p>
<p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p>
<p><strong>JRE:</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p>
<p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p>
<p><strong>区别与联系：</strong></p>
<ol>
<li>JDK用于开发，JRE用于运行java程序 ；</li>
<li>JDK和JRE中都包含JVM ；</li>
<li>JVM是java编程语言的核心并且具有平台独立性。</li>
</ol>
<h3 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下java中的编译器和解释器：</strong> 　　</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>
<p> Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p>
<p><strong>采用字节码的好处：</strong> 　　</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><ol>
<li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>
<li>接口中的实例变量默认是final类型的，而抽象类中则不一定 </li>
<li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li>
<li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
<p>注意：Java8 后接口可以有默认实现( default )。</p>
<h3 id="成员变量与局部变量的区别有那些？"><a href="#成员变量与局部变量的区别有那些？" class="headerlink" title="成员变量与局部变量的区别有那些？"></a>成员变量与局部变量的区别有那些？</h3><ol>
<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li>
<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li>
</ol>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>
<p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>
<h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><p>1) 形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br>2) 含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br>3) 占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第二周(2018-8-13)/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第一周（2018-8-7）/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.476Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <h2 id="一-为什么-Java-中只有值传递？"><a href="#一-为什么-Java-中只有值传递？" class="headerlink" title="一 为什么 Java 中只有值传递？"></a>一 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p><strong>下面通过 3 个例子来给大家说明</strong></p>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>
<h3 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">	change(arr);</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">	array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<h3 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">		Test.swap(s1, s2);</span><br><span class="line">		System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">		System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">		Student temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = temp;</span><br><span class="line">		System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">		System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>交换之前：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt></p>
<p>交换之后：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt></p>
<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>
<p>下面再总结一下Java中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>
<h2 id="二-与equals-重要"><a href="#二-与equals-重要" class="headerlink" title="二  ==与equals(重要)"></a>二  ==与equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
<h2 id="三-hashCode与equals（重要）"><a href="#三-hashCode与equals（重要）" class="headerlink" title="三  hashCode与equals（重要）"></a>三  hashCode与equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment"> * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment"> * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment"> * technique is not required by the</span></span><br><span class="line"><span class="comment"> * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode"></a>为什么要有hashCode</h3><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h3 id="为什么两个对象有相同的hashcode值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的hashcode值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的hashcode值，它们也不一定是相等的？"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/zhzhao999/article/details/53449504" target="_blank" rel="noopener">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>
<p><a href="https://www.cnblogs.com/Eason-S/p/5524837.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第一周（2018-8-7）/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/BATJrealInterviewExperience/2019alipay-pinduoduo-toutiao/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.472Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <p>作者： rhwayfun,原文地址：<a href="https://mp.weixin.qq.com/s/msYty4vjjC0PvrwasRH5Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/msYty4vjjC0PvrwasRH5Bw</a> ,JavaGuide 已经获得作者授权并对原文进行了重新排版。</p>
<!-- TOC -->

<ul>
<li><a href="#写在2019年后的蚂蚁头条拼多多的面试总结">写在2019年后的蚂蚁、头条、拼多多的面试总结</a><ul>
<li><a href="#准备过程">准备过程</a></li>
<li><a href="#蚂蚁金服">蚂蚁金服</a><ul>
<li><a href="#一面">一面</a></li>
<li><a href="#二面">二面</a></li>
<li><a href="#三面">三面</a></li>
<li><a href="#四面">四面</a></li>
<li><a href="#五面">五面</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#拼多多">拼多多</a><ul>
<li><a href="#面试前">面试前</a></li>
<li><a href="#一面-1">一面</a></li>
<li><a href="#二面-1">二面</a></li>
<li><a href="#三面-1">三面</a></li>
<li><a href="#小结-1">小结</a></li>
</ul>
</li>
<li><a href="#字节跳动">字节跳动</a><ul>
<li><a href="#面试前-1">面试前</a></li>
<li><a href="#一面-2">一面</a></li>
<li><a href="#二面-2">二面</a></li>
<li><a href="#小结-2">小结</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="2019年蚂蚁金服、头条、拼多多的面试总结"><a href="#2019年蚂蚁金服、头条、拼多多的面试总结" class="headerlink" title="2019年蚂蚁金服、头条、拼多多的面试总结"></a>2019年蚂蚁金服、头条、拼多多的面试总结</h1><p>文章有点长，请耐心看完，绝对有收获！不想听我BB直接进入面试分享：</p>
<ul>
<li>准备过程</li>
<li>蚂蚁金服面试分享</li>
<li>拼多多面试分享</li>
<li>字节跳动面试分享</li>
<li>总结</li>
</ul>
<p>说起来开始进行面试是年前倒数第二周，上午9点，我还在去公司的公交上，突然收到蚂蚁的面试电话，其实算不上真正的面试。面试官只是和我聊了下他们在做的事情（主要是做双十一这里大促的稳定性保障，偏中间件吧），说的很详细，然后和我沟通了下是否有兴趣，我表示有兴趣，后面就收到正式面试的通知，最后没选择去蚂蚁表示抱歉。</p>
<p>当时我自己也准备出去看看机会，顺便看看自己的实力。当时我其实挺纠结的，一方面现在部门也正需要我，还是可以有一番作为的，另一方面觉得近一年来进步缓慢，没有以前飞速进步的成就感了，而且业务和技术偏于稳定，加上自己也属于那种比较懒散的人，骨子里还是希望能够突破现状，持续在技术上有所精进。</p>
<p>在开始正式的总结之前，还是希望各位同仁能否听我继续发泄一会，抱拳！</p>
<p>我翻开自己2018年初立的flag，觉得甚是惭愧。其中就有一条是保持一周写一篇博客，奈何中间因为各种原因没能坚持下去。细细想来，主要是自己没能真正静下来心认真投入到技术的研究和学习，那么为什么会这样？说白了还是因为没有确定目标或者目标不明确，没有目标或者目标不明确都可能导致行动的失败。</p>
<p>那么问题来了，目标是啥？就我而言，短期目标是深入研究某一项技术，比如最近在研究mysql，那么深入研究一定要动手实践并且有所产出，这就够了么？还需要我们能够举一反三，结合实际开发场景想一想日常开发要注意什么，这中间有没有什么坑？可以看出，要进步真的不是一件简单的事，这种反人类的行为需要我们克服自我的弱点，逐渐形成习惯。真正牛逼的人，从不觉得认真学习是一件多么难的事，因为这已经形成了他的习惯，就喝早上起床刷牙洗脸那么自然简单。</p>
<p>扯了那么多，开始进入正题，先后进行了蚂蚁、拼多多和字节跳动的面试。</p>
<h2 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h2><p>先说说我自己的情况，我2016先在蚂蚁实习了将近三个月，然后去了我现在的老东家，2.5年工作经验，可以说毕业后就一直老老实实在老东家打怪升级，虽说有蚂蚁的实习经历，但是因为时间太短，还是有点虚的。所以面试官看到我简历第一个问题绝对是这样的。</p>
<p>“哇，你在蚂蚁待过，不错啊”，面试官笑嘻嘻地问到。“是的，还好”，我说。“为啥才三个月？”，面试官脸色一沉问到。“哗啦啦解释一通。。。”，我解释道。“哦，原来如此，那我们开始面试吧”，面试官一本正经说到。</p>
<p>尼玛，早知道不写蚂蚁的实习经历了，后面仔细一想，当初写上蚂蚁不就给简历加点料嘛。</p>
<p>言归正传，准备过程其实很早开始了（当然这不是说我工作时老想着跳槽，因为我明白现在的老东家并不是终点，我还需要不断提升），具体可追溯到从蚂蚁离职的时候，当时出来也面了很多公司，没啥大公司，面了大概5家公司，都拿到offer了。</p>
<p>工作之余常常会去额外研究自己感兴趣的技术以及工作用到的技术，力求把原理搞明白，并且会自己实践一把。此外，买了N多书，基本有时间就会去看，补补基础，什么操作系统、数据结构与算法、MySQL、JDK之类的源码，基本都好好温习了（文末会列一下自己看过的书和一些好的资料）。<strong>我深知基础就像“木桶效应”的短板，决定了能装多少水。</strong></p>
<p>此外，在正式决定看机会之前，我给自己列了一个提纲，主要包括Java要掌握的核心要点，有不懂的就查资料搞懂。我给自己定位还是Java工程师，所以Java体系是一定要做到心中有数的，很多东西没有常年的积累面试的时候很容易露馅，学习要对得起自己，不要骗人。</p>
<p>剩下的就是找平台和内推了，除了蚂蚁，头条和拼多多都是找人内推的，感谢蚂蚁面试官对我的欣赏，以后说不定会去蚂蚁咯😄。</p>
<p>平台：脉脉、GitHub、v2</p>
<h2 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvt9qal7lJSgfGJ8mq00yE1J4UQ9H1oo9t6RAL4T3whhx17TYlj1mjlXA/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>一面</li>
<li>二面</li>
<li>三面</li>
<li>四面</li>
<li>五面</li>
<li>小结</li>
</ul>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面就做了一道算法题，要求两小时内完成，给了长度为N的有重复元素的数组，要求输出第10大的数。典型的TopK问题，快排算法搞定。</p>
<p>算法题要注意的是合法性校验、边界条件以及异常的处理。另外，如果要写测试用例，一定要保证测试覆盖场景尽可能全。加上平时刷刷算法题，这种考核应该没问题的。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul>
<li>自我介绍下呗</li>
<li>开源项目贡献过代码么？（Dubbo提过一个打印accesslog的bug算么）</li>
<li>目前在部门做什么，业务简单介绍下，内部有哪些系统，作用和交互过程说下</li>
<li>Dubbo踩过哪些坑，分别是怎么解决的？（说了异常处理时业务异常捕获的问题，自定义了一个异常拦截器）</li>
<li>开始进入正题，说下你对线程安全的理解（多线程访问同一个对象，如果不需要考虑额外的同步，调用对象的行为就可以获得正确的结果就是线程安全）</li>
<li>事务有哪些特性？（ACID）</li>
<li>怎么理解原子性？（同一个事务下，多个操作要么成功要么失败，不存在部分成功或者部分失败的情况）</li>
<li>乐观锁和悲观锁的区别？（悲观锁假定会发生冲突，访问的时候都要先获得锁，保证同一个时刻只有线程获得锁，读读也会阻塞；乐观锁假设不会发生冲突，只有在提交操作的时候检查是否有冲突）这两种锁在Java和MySQL分别是怎么实现的？（Java乐观锁通过CAS实现，悲观锁通过synchronize实现。mysql乐观锁通过MVCC，也就是版本实现，悲观锁可以通过select… for update加上排它锁） </li>
<li>HashMap为什么不是线程安全的？（多线程操作无并发控制，顺便说了在扩容的时候多线程访问时会造成死锁，会形成一个环，不过扩容时多线程操作形成环的问题再JDK1.8已经解决，但多线程下使用HashMap还会有一些其他问题比如数据丢失，所以多线程下不应该使用HashMap，而应该使用ConcurrentHashMap）怎么让HashMap变得线程安全？(Collections的synchronize方法包装一个线程安全的Map，或者直接用ConcurrentHashMap)两者的区别是什么？（前者直接在put和get方法加了synchronize同步，后者采用了分段锁以及CAS支持更高的并发）</li>
<li>jdk1.8对ConcurrentHashMap做了哪些优化？（插入的时候如果数组元素使用了红黑树，取消了分段锁设计，synchronize替代了Lock锁）为什么这样优化？（避免冲突严重时链表多长，提高查询效率，时间复杂度从O(N)提高到O(logN)）</li>
<li>redis主从机制了解么？怎么实现的？</li>
<li>有过GC调优的经历么？（有点虚，答得不是很好）</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul>
<li>简单自我介绍下</li>
<li>监控系统怎么做的，分为哪些模块，模块之间怎么交互的？用的什么数据库？（MySQL）使用什么存储引擎，为什么使用InnnoDB？(支持事务、聚簇索引、MVCC)</li>
<li>订单表有做拆分么，怎么拆的？(垂直拆分和水平拆分)</li>
<li>水平拆分后查询过程描述下</li>
<li>如果落到某个分片的数据很大怎么办？(按照某种规则，比如哈希取模、range，将单张表拆分为多张表)</li>
<li>哈希取模会有什么问题么？(有的，数据分布不均，扩容缩容相对复杂 )</li>
<li>分库分表后怎么解决读写压力？(一主多从、多主多从)</li>
<li>拆分后主键怎么保证惟一？(UUID、Snowflake算法)</li>
<li>Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增)</li>
<li>怎么实现全局递增的唯一ID？(讲了TDDL的一次取一批ID，然后再本地慢慢分配的做法)</li>
<li>Mysql的索引结构说下(说了B+树，B+树可以对叶子结点顺序查找，因为叶子结点存放了数据结点且有序)</li>
<li>主键索引和普通索引的区别(主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID，查询的时候需要做一次回表查询)一定要回表查询么？(不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理)</li>
<li>你们系统目前的瓶颈在哪里？</li>
<li>你打算怎么优化？简要说下你的优化思路</li>
<li>有什么想问我么？</li>
</ul>
<h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ul>
<li>介绍下自己</li>
<li>为什么要做逆向？</li>
<li>怎么理解微服务？</li>
<li>服务治理怎么实现的？(说了限流、压测、监控等模块的实现)</li>
<li>这个不是中间件做的事么，为什么你们部门做？(当时没有单独的中间件团队，微服务刚搞不久，需要进行监控和性能优化)</li>
<li>说说Spring的生命周期吧</li>
<li>说说GC的过程(说了young gc和full gc的触发条件和回收过程以及对象创建的过程)</li>
<li>CMS GC有什么问题？(并发清除算法，浮动垃圾，短暂停顿)</li>
<li>怎么避免产生浮动垃圾？(记得有个VM参数设置可以让扫描新生代之前进行一次young gc，但是因为gc是虚拟机自动调度的，所以不保证一定执行。但是还有参数可以让虚拟机强制执行一次young gc)</li>
<li>强制young gc会有什么问题？(STW停顿时间变长)</li>
<li>知道G1么？(了解一点 )</li>
<li>回收过程是怎么样的？(young gc、并发阶段、混合阶段、full gc，说了Remember Set)</li>
<li>你提到的Remember Set底层是怎么实现的？</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h3><p>五面是HRBP面的，和我提前预约了时间，主要聊了之前在蚂蚁的实习经历、部门在做的事情、职业发展、福利待遇等。阿里面试官确实是具有一票否决权的，很看重你的价值观是否match，一般都比较喜欢皮实的候选人。HR面一定要诚实，不要说谎，只要你说谎HR都会去证实，直接cut了。</p>
<ul>
<li>之前蚂蚁实习三个月怎么不留下来？</li>
<li>实习的时候主管是谁？</li>
<li>实习做了哪些事情？（尼玛这种也问？）</li>
<li>你对技术怎么看？平时使用什么技术栈？（阿里HR真的是既当爹又当妈，😂）</li>
<li>最近有在研究什么东西么</li>
<li>你对SRE怎么看</li>
<li>对待遇有什么预期么</li>
</ul>
<p>最后HR还对我说目前稳定性保障部挺缺人的，希望我尽快回复。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>蚂蚁面试比较重视基础，所以Java那些基本功一定要扎实。蚂蚁的工作环境还是挺赞的，因为我面的是稳定性保障部门，还有许多单独的小组，什么三年1班，很有青春的感觉。面试官基本水平都比较高，基本都P7以上，除了基础还问了不少架构设计方面的问题，收获还是挺大的。</p>
<h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtsmoh9TdJcV0hwnrjtbWPdOacyj2uYe2qaI5jvlGIQHwYtknwnGTibbQ/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>面试前</li>
<li>一面</li>
<li>二面</li>
<li>三面</li>
<li>小结</li>
</ul>
<h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p>面完蚂蚁后，早就听闻拼多多这个独角兽，决定也去面一把。首先我在脉脉找了一个拼多多的HR，加了微信聊了下，发了简历便开始我的拼多多面试之旅。这里要非常感谢拼多多HR小姐姐，从面试内推到offer确认一直都在帮我，人真的很nice。</p>
<h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ul>
<li>为啥蚂蚁只待了三个月？没转正？(转正了，解释了一通。。。)</li>
<li>Java中的HashMap、TreeMap解释下？(TreeMap红黑树，有序，HashMap无序，数组+链表)</li>
<li>TreeMap查询写入的时间复杂度多少？(O(logN))</li>
<li>HashMap多线程有什么问题？(线程安全，死锁)怎么解决？( jdk1.8用了synchronize + CAS，扩容的时候通过CAS检查是否有修改，是则重试)重试会有什么问题么？(CAS（Compare And Swap）是比较和交换，不会导致线程阻塞，但是因为重试是通过自旋实现的，所以仍然会占用CPU时间，还有ABA的问题)怎么解决？(超时，限定自旋的次数，ABA可以通过原理变量AtomicStampedReference解决，原理利用版本号进行比较)超过重试次数如果仍然失败怎么办？(synchronize互斥锁)</li>
<li>CAS和synchronize有什么区别？都用synchronize不行么？(CAS是乐观锁，不需要阻塞，硬件级别实现的原子性；synchronize会阻塞，JVM级别实现的原子性。使用场景不同，线程冲突严重时CAS会造成CPU压力过大，导致吞吐量下降，synchronize的原理是先自旋然后阻塞，线程冲突严重仍然有较高的吞吐量，因为线程都被阻塞了，不会占用CPU<br>)</li>
<li>如果要保证线程安全怎么办？(ConcurrentHashMap)</li>
<li>ConcurrentHashMap怎么实现线程安全的？(分段锁)</li>
<li>get需要加锁么，为什么？(不用，volatile关键字)</li>
<li>volatile的作用是什么？(保证内存可见性)</li>
<li>底层怎么实现的？(说了主内存和工作内存，读写内存屏障，happen-before，并在纸上画了线程交互图)</li>
<li>在多核CPU下，可见性怎么保证？(思考了一会，总线嗅探技术)</li>
<li>聊项目，系统之间是怎么交互的？</li>
<li>系统并发多少，怎么优化？</li>
<li>给我一张纸，画了一个九方格，都填了数字，给一个M<em>N矩阵，从1开始逆时针打印这M</em>N个数，要求时间复杂度尽可能低（内心OS：之前貌似碰到过这题，最优解是怎么实现来着）思考中。。。</li>
<li>可以先说下你的思路(想起来了，说了什么时候要变换方向的条件，向右、向下、向左、向上，依此循环)</li>
<li>有什么想问我的？</li>
</ul>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul>
<li>自我介绍下</li>
<li>手上还有其他offer么？(拿了蚂蚁的offer)</li>
<li>部门组织结构是怎样的？(这轮不是技术面么，不过还是老老实实说了)</li>
<li>系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？（面试官有点秃顶，一看级别就很高）给了我一张纸，我在上面简单画了下系统之间的流转情况</li>
<li>链路追踪的信息是怎么传递的？(RpcContext的attachment，说了Span的结构:parentSpanId + curSpanId)</li>
<li>SpanId怎么保证唯一性？(UUID，说了下内部的定制改动)</li>
<li>RpcContext是在什么维度传递的？(线程)</li>
<li>Dubbo的远程调用怎么实现的？(讲了读取配置、拼装url、创建Invoker、服务导出、服务注册以及消费者通过动态代理、filter、获取Invoker列表、负载均衡等过程（哗啦啦讲了10多分钟），我可以喝口水么)</li>
<li>Spring的单例是怎么实现的？(单例注册表)</li>
<li>为什么要单独实现一个服务治理框架？(说了下内部刚搞微服务不久，主要对服务进行一些监控和性能优化)</li>
<li>谁主导的？内部还在使用么？ </li>
<li>逆向有想过怎么做成通用么？</li>
<li>有什么想问的么？</li>
</ul>
<h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>二面老大面完后就直接HR面了，主要问了些职业发展、是否有其他offer、以及入职意向等问题，顺便说了下公司的福利待遇等，都比较常规啦。不过要说的是手上有其他offer或者大厂经历会有一定加分。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>拼多多的面试流程就简单许多，毕竟是一个成立三年多的公司。面试难度中规中矩，只要基础扎实应该不是问题。但不得不说工作强度很大，开始面试前HR就提前和我确认能否接受这样强度的工作，想来的老铁还是要做好准备</p>
<h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zsXjkGNcic53JMPc0FUw1lBXl5iaibrEXvtRoTSCMeUWramk7M4CekxE9ssH5DFGBxmDcw0x9hjzmbIGHVWenDK8w/?wx_fmt=jpeg" alt="img"></p>
<ul>
<li>面试前</li>
<li>一面</li>
<li>二面</li>
<li>小结</li>
</ul>
<h3 id="面试前-1"><a href="#面试前-1" class="headerlink" title="面试前"></a>面试前</h3><p>头条的面试是三家里最专业的，每次面试前有专门的HR和你约时间，确定OK后再进行面试。每次都是通过视频面试，因为都是之前都是电话面或现场面，所以视频面试还是有点不自然。也有人觉得视频面试体验很赞，当然萝卜青菜各有所爱。最坑的二面的时候对方面试官的网络老是掉线，最后很冤枉的挂了（当然有一些点答得不好也是原因之一）。所以还是有点遗憾的。</p>
<h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ul>
<li>先自我介绍下</li>
<li>聊项目，逆向系统是什么意思</li>
<li>聊项目，逆向系统用了哪些技术</li>
<li>线程池的线程数怎么确定？</li>
<li>如果是IO操作为主怎么确定？</li>
<li>如果计算型操作又怎么确定？</li>
<li>Redis熟悉么，了解哪些数据结构?(说了zset) zset底层怎么实现的?(跳表)</li>
<li>跳表的查询过程是怎么样的，查询和插入的时间复杂度?(说了先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是O(logN))</li>
<li>红黑树了解么，时间复杂度?(说了是N叉平衡树，O(logN))</li>
<li>既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树(跳表实现简单，踩坑成本低，红黑树每次插入都要通过旋转以维持平衡，实现复杂)</li>
<li>点了点头，说下Dubbo的原理?(说了服务注册与发布以及消费者调用的过程)踩过什么坑没有？（说了dubbo异常处理的和打印accesslog的问题）</li>
<li>CAS了解么？（说了CAS的实现）还了解其他同步机制么？（说了synchronize以及两者的区别，一个乐观锁，一个悲观锁）</li>
<li>那我们做一道题吧，数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数</li>
<li>先说下你的思路（从0下标开始遍历，如果是奇数下标判断该元素是否奇数，是则跳过，否则从该位置寻找下一个奇数）</li>
<li>下一个奇数？怎么找？（有点懵逼，思考中。。）</li>
<li>有思路么？（仍然是先遍历一次数组，并对下标进行判断，如果下标属性和该位置元素不匹配从当前下标的下一个遍历数组元素，然后替换）</li>
<li>你这样时间复杂度有点高，如果要求O(N)要怎么做（思考一会，答道“定义两个指针，分别从下标0和1开始遍历，遇见奇数位是是偶数和偶数位是奇数就停下，交换内容”）</li>
<li>时间差不多了，先到这吧。你有什么想问我的？</li>
</ul>
<h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><ul>
<li>面试官和蔼很多，你先介绍下自己吧</li>
<li>你对服务治理怎么理解的？</li>
<li>项目中的限流怎么实现的？（Guava ratelimiter，令牌桶算法）</li>
<li>具体怎么实现的？（要点是固定速率且令牌数有限）</li>
<li>如果突然很多线程同时请求令牌，有什么问题？（导致很多请求积压，线程阻塞）</li>
<li>怎么解决呢？（可以把积压的请求放到消息队列，然后异步处理）</li>
<li>如果不用消息队列怎么解决？（说了RateLimiter预消费的策略）</li>
<li>分布式追踪的上下文是怎么存储和传递的？（ThreadLocal + spanId，当前节点的spanId作为下个节点的父spanId）</li>
<li>Dubbo的RpcContext是怎么传递的？（ThreadLocal）主线程的ThreadLocal怎么传递到线程池？（说了先在主线程通过ThreadLocal的get方法拿到上下文信息，在线程池创建新的ThreadLocal并把之前获取的上下文信息设置到ThreadLocal中。这里要注意的线程池创建的ThreadLocal要在finally中手动remove，不然会有内存泄漏的问题）</li>
<li>你说的内存泄漏具体是怎么产生的？（说了ThreadLocal的结构，主要分两种场景：主线程仍然对ThreadLocal有引用和主线程不存在对ThreadLocal的引用。第一种场景因为主线程仍然在运行，所以还是有对ThreadLocal的引用，那么ThreadLocal变量的引用和value是不会被回收的。第二种场景虽然主线程不存在对ThreadLocal的引用，且该引用是弱引用，所以会在gc的时候被回收，但是对用的value不是弱引用，不会被内存回收，仍然会造成内存泄漏）</li>
<li>线程池的线程是不是必须手动remove才可以回收value？（是的，因为线程池的核心线程是一直存在的，如果不清理，那么核心线程的threadLocals变量会一直持有ThreadLocal变量）</li>
<li>那你说的内存泄漏是指主线程还是线程池？（主线程 ）</li>
<li>可是主线程不是都退出了，引用的对象不应该会主动回收么？（面试官和内存泄漏杠上了），沉默了一会。。。</li>
<li>那你说下SpringMVC不同用户登录的信息怎么保证线程安全的？（刚才解释的有点懵逼，一下没反应过来，居然回答成锁了。大脑有点晕了，此时已经一个小时过去了，感觉情况不妙。。。）</li>
<li>这个直接用ThreadLocal不就可以么，你见过SpringMVC有锁实现的代码么？（有点晕菜。。。）</li>
<li>我们聊聊mysql吧，说下索引结构（说了B+树）</li>
<li>为什么使用B+树？（ 说了查询效率高，O(logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据）</li>
<li>什么是索引覆盖？（忘记了。。。 ）</li>
<li>Java为什么要设计双亲委派模型？</li>
<li>什么时候需要自定义类加载器？</li>
<li>我们做一道题吧，手写一个对象池</li>
<li>有什么想问我的么？（感觉我很多点都没答好，是不是挂了（结果真的是） ）</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>头条的面试确实很专业，每次面试官会提前给你发一个视频链接，然后准点开始面试，而且考察的点都比较全。</p>
<p>面试官都有一个特点，会抓住一个值得深入的点或者你没说清楚的点深入下去直到你把这个点讲清楚，不然面试官会觉得你并没有真正理解。二面面试官给了我一点建议，研究技术的时候一定要去研究产生的背景，弄明白在什么场景解决什么特定的问题，其实很多技术内部都是相通的。很诚恳，还是很感谢这位面试官大大。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从年前开始面试到头条面完大概一个多月的时间，真的有点身心俱疲的感觉。最后拿到了拼多多、蚂蚁的offer，还是蛮幸运的。头条的面试对我帮助很大，再次感谢面试官对我的诚恳建议，以及拼多多的HR对我的啰嗦的问题详细解答。</p>
<p>这里要说的是面试前要做好两件事：简历和自我介绍，简历要好好回顾下自己做的一些项目，然后挑几个亮点项目。自我介绍基本每轮面试都有，所以最好提前自己练习下，想好要讲哪些东西，分别怎么讲。此外，简历提到的技术一定是自己深入研究过的，没有深入研究也最好找点资料预热下，不打无准备的仗。</p>
<p><strong>这些年看过的书</strong>：</p>
<p>《Effective Java》、《现代操作系统》、《TCP/IP详解：卷一》、《代码整洁之道》、《重构》、《Java程序性能优化》、《Spring实战》、《Zookeeper》、《高性能MySQL》、《亿级网站架构核心技术》、《可伸缩服务架构》、《Java编程思想》</p>
<p>说实话这些书很多只看了一部分，我通常会带着问题看书，不然看着看着就睡着了，简直是催眠良药😅。</p>
<p>最后，附一张自己面试前准备的脑图：</p>
<p>链接:<a href="https://pan.baidu.com/s/1o2l1tuRakBEP0InKEh4Hzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1o2l1tuRakBEP0InKEh4Hzw</a> 密码:300d</p>
<p>全文完。</p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/BATJrealInterviewExperience/2019alipay-pinduoduo-toutiao/">
                        Read More
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/14/docs/essential-content-for-interview/BATJrealInterviewExperience/5面阿里,终获offer/">
                        
                    </a>
                </h1>
                <div class="create">
                    <span>Created</span>
                    
                        <time datetime="2019-07-14T14:47:16.472Z">
                            2019-07-14
                        </time>
                    
                    
                </div>
                
                    <blockquote>
<p>作者：ppxyn。本文来自读者投稿，同时也欢迎各位投稿，<strong>对于不错的原创文章我根据你的选择给予现金(50-200)、付费专栏或者任选书籍进行奖励！所以，快提 pr 或者邮件的方式（邮件地址在主页）给我投稿吧！</strong> 当然，我觉得奖励是次要的，最重要的是你可以从自己整理知识点的过程中学习到很多知识。</p>
</blockquote>
<p><strong>目录</strong></p>
<!-- MarkdownTOC -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#一面技术面">一面(技术面)</a></li>
<li><a href="#二面技术面">二面(技术面)</a></li>
<li><a href="#三面技术面">三面(技术面)</a></li>
<li><a href="#四面半个技术面">四面(半个技术面)</a></li>
<li><a href="#五面hr面">五面(HR面)</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- /MarkdownTOC -->

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在接触 Java 之前我接触的比较多的是硬件方面，用的比较多的语言就是C和C++。到了大三我才正式选择 Java 方向，到目前为止使用Java到现在大概有一年多的时间，所以Java算不上很好。刚开始投递的时候，实习刚辞职，也没准备笔试面试，很多东西都忘记了。所以，刚开始我并没有直接就投递阿里，毕竟心里还是有一点点小害怕的。于是，我就先投递了几个不算大的公司来练手，就是想着刷刷经验而已或者说是练练手（ps：还是挺对不起那些公司的）。面了一个月其他公司后，我找了我实验室的学长内推我，后面就有了这5次面试。</p>
<p>下面简单的说一下我的这5次面试：4次技术面+1次HR面，希望我的经历能对你有所帮助。</p>
<h3 id="一面-技术面"><a href="#一面-技术面" class="headerlink" title="一面(技术面)"></a>一面(技术面)</h3><ol>
<li>自我介绍（主要讲自己会的技术细节，项目经验，经历那些就一语带过，后面面试官会问你的）。</li>
<li>聊聊项目（就是一个很普通的分布式商城，自己做了一些改进），让我画了整个项目的架构图，然后针对项目抛了一系列的提高性能的问题，还问了我做项目的过程中遇到了那些问题，如何解决的，差不读就这些吧。</li>
<li>可能是我前面说了我会数据库优化，然后面试官就开始问索引、事务隔离级别、悲观锁和乐观锁、索引、ACID、MVVC这些问题。</li>
<li>浏览器输入URL发生了什么? TCP和UDP区别? TCP如何保证传输可靠性?</li>
<li>讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树</li>
<li>后面又问了很多JVM方面的问题，比如Java内存模型、常见的垃圾回收器、双亲委派模型这些</li>
<li>你有什么问题要问吗？</li>
</ol>
<h3 id="二面-技术面"><a href="#二面-技术面" class="headerlink" title="二面(技术面)"></a>二面(技术面)</h3><ol>
<li>自我介绍（主要讲自己会的技术细节，项目经验，经历那些就一语带过，后面面试官会问你的）。</li>
<li>操作系统的内存管理机制</li>
<li>进程和线程的区别</li>
<li>说下你对线程安全的理解</li>
<li>volatile 有什么作用 ，sychronized和lock有什么区别</li>
<li>ReentrantLock实现原理</li>
<li>用过CountDownLatch么？什么场景下用的？</li>
<li>AQS底层原理。</li>
<li>造成死锁的原因有哪些，如何预防？</li>
<li>加锁会带来哪些性能问题。如何解决？  </li>
<li>HashMap、ConcurrentHashMap源码。HashMap是线程安全的吗？Hashtable呢？ConcurrentHashMap有了解吗？    </li>
<li>是否可以实习？ </li>
<li>你有什么问题要问吗？  </li>
</ol>
<h3 id="三面-技术面"><a href="#三面-技术面" class="headerlink" title="三面(技术面)"></a>三面(技术面)</h3><ol>
<li>有没有参加过 ACM 或者他竞赛，有没有拿过什么奖？（  我说我没参加过ACM，本科参加过数学建模竞赛，名次并不好，没拿过什么奖。面试官好像有点失望，然后我又赶紧补充说我和老师一起做过一个项目，目前已经投入使用。面试官还比较感兴趣，后面又和他聊了一下这个项目。）</li>
<li>研究生期间，做过什么项目，发过论文吗？有什么成果吗？</li>
<li>你觉得你有什么优点和缺点？你觉得你相比于那些比你更优秀的人欠缺什么？</li>
<li>有读过什么源码吗？（我说我读过 Java 集合框架和 Netty 的，面试官说 Java 集合前几面一定问的差不多，就不问了，然后就问我 Netty的，我当时很慌啊！）</li>
<li>介绍一下自己对 Netty 的认识，为什么要用。说说业务中，Netty 的使用场景。什么是TCP 粘包/拆包,解决办法。Netty线程模型。Dubbo 在使用 Netty 作为网络通讯时候是如何避免粘包与半包问题？讲讲Netty的零拷贝？巴拉巴拉问了好多，我记得有好几个我都没回答上来，心里想着凉凉了啊。</li>
<li>用到了那些开源技术、在开源领域做过贡献吗？</li>
<li>常见的排序算法及其复杂度，现场写了快排。</li>
<li>红黑树，B树的一些问题。</li>
<li>讲讲算法及数据结构在实习项目中的用处。</li>
<li>自己的未来规划（就简单描述了一下自己未来的设想啊，说的还挺诚恳，面试官好像还挺满意的）</li>
<li>你有什么问题要问吗？  </li>
</ol>
<h3 id="四面-半个技术面"><a href="#四面-半个技术面" class="headerlink" title="四面(半个技术面)"></a>四面(半个技术面)</h3><p>三面面完当天，晚上9点接到面试电话，感觉像是部门或者项目主管。 这个和之前的面试不大相同，感觉面试官主要考察的是你解决问题的能力、学习能力和团队协作能力。</p>
<ol>
<li>让我讲一个自己觉得最不错的项目。然后就巴拉巴拉的聊，我记得主要是问了项目是如何进行协作的、遇到问题是如何解决的、与他人发生冲突是如何解决的这些。感觉聊了挺久。</li>
<li>出现 OOM 后你会怎么排查问题？</li>
<li>自己平时是如何学习新技术的？除了 Java 还回去了解其他技术吗?</li>
<li>上一段实习经历的收获。</li>
<li>NginX如何做负载均衡、常见的负载均衡算法有哪些、一致性哈希的一致性是什么意思、一致性哈希是如何做哈希的  </li>
<li>你有什么问题问我吗？</li>
<li>还有一些其他的，想不起来了，感觉这一面不是偏向技术来问。</li>
</ol>
<h2 id="五面-HR面"><a href="#五面-HR面" class="headerlink" title="五面(HR面)"></a>五面(HR面)</h2><ol>
<li>自我介绍（主要讲能突出自己的经历，会的编程技术一语带过）。</li>
<li>你觉得你有什么优点和缺点？如何克服这些缺点？</li>
<li>说一件大学里你自己比较有成就感的一件事情，为此付出了那些努力。</li>
<li>你前面跟其他面试官讲过一些你做的项目吧？可以给我讲讲吗？你要考虑到我不是一个做技术的人，怎么让我也听得懂。项目中有什么问题，你怎么解决的？你最大的收获是什么？</li>
<li>你目前有面试过其他公司吗？如果让你选，这些公司和阿里，你选哪个？（送分题，回答不好可能送命）</li>
<li>你期望的工作地点是哪里？</li>
<li>你有什么问题吗？</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>可以看出面试官问我的很多问题都是比较常见的问题，所以记得一定要提前准备，还要深入准备，不要回答的太皮毛。很多时候一个问题可能会牵扯出很多问题，遇到不会的问题不要慌，冷静分析，如果你真的回答不上来，也不要担心自己是不是就要挂了，很可能这个问题本身就比较难。</li>
<li>表达能力和沟通能力太重要了，一定要提前练一下，我自身就是一个不太会说话的人，所以，面试前我对于自我介绍、项目介绍和一些常见问题都在脑子里练了好久，确保面试的时候能够很清晰和简洁的说出来。</li>
<li>等待面试的过程和面试的过程真的好熬人，那段时间我压力也比较大，好在我私下找到学长聊了很多，心情也好了很多。</li>
<li>面试之后及时总结，面的好的话，不要得意，尽快准备下一场面试吧！</li>
</ol>
<p>我觉得我还算是比较幸运的，最后也祝大家都能获得心仪的Offer。</p>

                
                <div class="readmore">
                    <a href="/2019/07/14/docs/essential-content-for-interview/BATJrealInterviewExperience/5面阿里,终获offer/">
                        Read More
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">syf</h3></a>
    <h4></h4>
    <div class="social">
        
            
              <a href="https://github.com/suyoufu1" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">About</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                Tags
                <sup style="font-size: 12px">
                    [0]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>Categories</h2>
    
        <p>None.</p>
    
</aside>

    
<aside id="acchives">
    <h2>Archives</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
</nav>

    </div>
</div>
<footer id="footer">
    <div id="copyright">&copy; syf  2019</div>
    <div id="theme">
        Powered by <a href="http://hexo.io">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
