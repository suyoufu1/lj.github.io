<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="苏有福的博客">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="苏有福的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏有福的博客">





  
  
  <link rel="canonical" href="http://yoursite.com/page/8/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>苏有福的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏有福的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/github-trending/2019-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/github-trending/2019-3/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-JavaGuide"><a href="#1-JavaGuide" class="headerlink" title="1. JavaGuide"></a>1. JavaGuide</h3><ul>
<li><strong>Github 地址</strong>： <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li>
<li><strong>Star</strong>:  32.9k (6,196 stars this month)</li>
<li><strong>介绍</strong>: 【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li>
</ul>
<h3 id="2-advanced-java"><a href="#2-advanced-java" class="headerlink" title="2.advanced-java"></a>2.advanced-java</h3><ul>
<li><strong>Github 地址</strong>：<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li>
<li><strong>Star</strong>: 15.1k (4,012 stars this month)</li>
<li><strong>介绍</strong>: 互联网 Java 工程师进阶知识完全扫盲。</li>
</ul>
<h3 id="3-spring-boot-examples"><a href="#3-spring-boot-examples" class="headerlink" title="3.spring-boot-examples"></a>3.spring-boot-examples</h3><ul>
<li><strong>Github 地址</strong>：<a href="https://github.com/ityouknow/spring-boot-examples" target="_blank" rel="noopener">https://github.com/ityouknow/spring-boot-examples</a></li>
<li><strong>Star</strong>: 12.8k (3,462 stars this month)</li>
<li><strong>介绍</strong>:  Spring Boot 教程、技术栈示例代码，快速简单上手教程。</li>
</ul>
<h3 id="4-mall"><a href="#4-mall" class="headerlink" title="4. mall"></a>4. mall</h3><ul>
<li><strong>Github 地址</strong>： <a href="https://github.com/macrozheng/mall" target="_blank" rel="noopener">https://github.com/macrozheng/mall</a></li>
<li><strong>star</strong>: 9.7 k (2,418 stars this month)</li>
<li><strong>介绍</strong>: mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</li>
</ul>
<h3 id="5-seata"><a href="#5-seata" class="headerlink" title="5. seata"></a>5. seata</h3><ul>
<li><strong>Github 地址</strong> : <a href="https://github.com/seata/seata" target="_blank" rel="noopener">https://github.com/seata/seata</a></li>
<li><strong>star</strong>: 7.2 k (1359 stars this month)</li>
<li><strong>介绍</strong>:  Seata 是一种易于使用，高性能，基于 Java 的开源分布式事务解决方案。</li>
</ul>
<h3 id="6-quarkus"><a href="#6-quarkus" class="headerlink" title="6. quarkus"></a>6. quarkus</h3><ul>
<li><strong>Github 地址</strong>：<a href="https://github.com/quarkusio/quarkus" target="_blank" rel="noopener">https://github.com/quarkusio/quarkus</a></li>
<li><strong>star</strong>: 12 k (1,224 stars this month)</li>
<li><strong>介绍</strong>: Quarkus 是为 GraalVM 和 HotSpot 量身定制的 Kubernetes Native Java 框架，由最佳的 Java 库和标准精心打造而成。Quarkus 的目标是使 Java 成为 Kubernetes 和无服务器环境中的领先平台，同时为开发人员提供统一的反应式和命令式编程模型，以优化地满足更广泛的分布式应用程序架构。</li>
</ul>
<h3 id="7-arthas"><a href="#7-arthas" class="headerlink" title="7. arthas"></a>7. arthas</h3><ul>
<li><strong>Github 地址</strong>：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li><strong>star</strong>: 11.6 k (1,199 stars this month)</li>
<li><strong>介绍</strong>: Arthas 是 Alibaba 开源的 Java 诊断工具。</li>
</ul>
<h3 id="8-DoraemonKit"><a href="#8-DoraemonKit" class="headerlink" title="8.DoraemonKit"></a>8.DoraemonKit</h3><ul>
<li><strong>Github 地址</strong>： <a href="https://github.com/didi/DoraemonKit" target="_blank" rel="noopener">https://github.com/didi/DoraemonKit</a></li>
<li><strong>Star</strong>: 6.2k (1,177 stars this month)</li>
<li><strong>介绍</strong>: 简称 “DoKit” 。一款功能齐全的客户端（ iOS 、Android ）研发助手，你值得拥有。</li>
</ul>
<h3 id="9-elasticsearch"><a href="#9-elasticsearch" class="headerlink" title="9.elasticsearch"></a>9.elasticsearch</h3><ul>
<li><strong>Github 地址</strong>  <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></li>
<li><strong>Star</strong>: 39.7k (1,069 stars this month)</li>
<li><strong>介绍</strong>: 开源，分布式，RESTful 搜索引擎。</li>
</ul>
<h3 id="10-tutorials"><a href="#10-tutorials" class="headerlink" title="10. tutorials"></a>10. tutorials</h3><ul>
<li><strong>Github 地址</strong>：<a href="https://github.com/eugenp/tutorials" target="_blank" rel="noopener">https://github.com/eugenp/tutorials</a></li>
<li><strong>star</strong>: 13 k (998 stars this month)</li>
<li><strong>介绍</strong>:  该项目是一系列小而专注的教程 - 每个教程都涵盖 Java 生态系统中单一且定义明确的开发领域。 当然，它们的重点是 Spring Framework  -  Spring，Spring Boot 和 Spring Securiyt。 除了 Spring 之外，还有以下技术：核心 Java，Jackson，HttpClient，Guava。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/面试必备之乐观锁与悲观锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/面试必备之乐观锁与悲观锁/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p>
<!-- TOC -->

<ul>
<li><a href="#何谓悲观锁与乐观锁">何谓悲观锁与乐观锁</a><ul>
<li><a href="#悲观锁">悲观锁</a></li>
<li><a href="#乐观锁">乐观锁</a></li>
<li><a href="#两种锁的使用场景">两种锁的使用场景</a></li>
</ul>
</li>
<li><a href="#乐观锁常见的两种实现方式">乐观锁常见的两种实现方式</a><ul>
<li><a href="#1-版本号机制">1. 版本号机制</a></li>
<li><a href="#2-cas算法">2. CAS算法</a></li>
</ul>
</li>
<li><a href="#乐观锁的缺点">乐观锁的缺点</a><ul>
<li><a href="#1-aba-问题">1 ABA 问题</a></li>
<li><a href="#2-循环时间长开销大">2 循环时间长开销大</a></li>
<li><a href="#3-只能保证一个共享变量的原子操作">3 只能保证一个共享变量的原子操作</a></li>
</ul>
</li>
<li><a href="#cas与synchronized的使用情景">CAS与synchronized的使用情景</a></li>
</ul>
<!-- /TOC -->

<h3 id="何谓悲观锁与乐观锁"><a href="#何谓悲观锁与乐观锁" class="headerlink" title="何谓悲观锁与乐观锁"></a>何谓悲观锁与乐观锁</h3><blockquote>
<p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p>
</blockquote>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V </li>
<li>进行比较的值 A </li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《<br>面试必备之深入理解自旋锁》</a></p>
<h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote>
<p> ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“面试突击”</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/简历模板/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/简历模板/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>手机：</li>
<li>Email：</li>
<li>微信：</li>
</ul>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>姓名/性别/出生日期 </li>
<li>本科/xxx计算机系xxx专业/英语六级</li>
<li>技术博客：<a href="http://snailclimb.top/" target="_blank" rel="noopener">http://snailclimb.top/</a> </li>
<li>荣誉奖励：获得了什么奖（获奖时间）</li>
<li>Github：<a href="https://github.com/Snailclimb" target="_blank" rel="noopener">https://github.com/Snailclimb </a></li>
<li>Github Resume: <a href="http://resume.github.io/?Snailclimb" target="_blank" rel="noopener">http://resume.github.io/?Snailclimb</a></li>
<li>期望职位：Java 研发程序员/大数据工程师(Java后台开发为首选)</li>
<li>期望城市：xxx城市</li>
</ul>
<h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="xxx项目"><a href="#xxx项目" class="headerlink" title="xxx项目"></a>xxx项目</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>介绍该项目是做什么的、使用到了什么技术以及你对项目整体设计的一个感受</p>
<h3 id="责任描述"><a href="#责任描述" class="headerlink" title="责任描述"></a>责任描述</h3><p>主要可以从下面三点来写：</p>
<ol>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h1 id="开源项目和技术文章"><a href="#开源项目和技术文章" class="headerlink" title="开源项目和技术文章"></a>开源项目和技术文章</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul>
<li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">Java-Guide</a> ：一份涵盖大部分Java程序员所需要掌握的核心知识。Star:3.9K; Fork:0.9k。</li>
</ul>
<h2 id="技术文章推荐"><a href="#技术文章推荐" class="headerlink" title="技术文章推荐"></a>技术文章推荐</h2><ul>
<li><a href="https://juejin.im/post/5b7d69e4e51d4538ca5730cb" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a></li>
<li><a href="https://juejin.im/post/5b85ea54e51d4538dd08f601" target="_blank" rel="noopener">搞定JVM垃圾回收就是这么简单</a></li>
<li><a href="https://juejin.im/post/5b3b19856fb9a04fa42f8c71" target="_blank" rel="noopener">前端&amp;后端程序员必备的Linux基础知识</a></li>
<li><a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></li>
</ul>
<h1 id="校园经历（可选）"><a href="#校园经历（可选）" class="headerlink" title="校园经历（可选）"></a>校园经历（可选）</h1><h2 id="2016-2017"><a href="#2016-2017" class="headerlink" title="2016-2017"></a>2016-2017</h2><p>担任学校社团-致深社副会长，主要负责团队每周活动的组建以及每周例会的主持。</p>
<h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p> 担任学校传媒组织：“长江大学在线信息传媒”的副站长以及安卓组成员。主要负责每周例会主持、活动策划以及学校校园通APP的研发工作。</p>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p>
<ul>
<li>Web开发：PHP/Hack/Node</li>
<li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li>
<li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li>
<li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li>
<li>数据库相关：MySQL/PgSQL/PDO/SQLite</li>
<li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li>
<li>单元测试：PHPUnit/SimpleTest/Qunit</li>
<li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li>
</ul>
<h1 id="自我评价（可选）"><a href="#自我评价（可选）" class="headerlink" title="自我评价（可选）"></a>自我评价（可选）</h1><p>自我发挥。切记不要过度自夸！！！</p>
<h3 id="感谢您花时间阅读我的简历，期待能有机会和您共事。"><a href="#感谢您花时间阅读我的简历，期待能有机会和您共事。" class="headerlink" title="感谢您花时间阅读我的简历，期待能有机会和您共事。"></a>感谢您花时间阅读我的简历，期待能有机会和您共事。</h3>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/手把手教你用Markdown写一份高质量的简历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/手把手教你用Markdown写一份高质量的简历/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Markdown-简历模板样式一览"><a href="#Markdown-简历模板样式一览" class="headerlink" title="Markdown 简历模板样式一览"></a>Markdown 简历模板样式一览</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f91e4843bd67?w=800&h=1737&f=png&s=97357" alt><br><strong>可以看到我把联系方式放在第一位，因为公司一般会与你联系，所以把联系方式放在第一位也是为了方便联系考虑。</strong></p>
<h2 id="为什么要用-Markdown-写简历？"><a href="#为什么要用-Markdown-写简历？" class="headerlink" title="为什么要用 Markdown 写简历？"></a>为什么要用 Markdown 写简历？</h2><p>Markdown 语法简单，易于上手。使用正确的 Markdown 语言写出来的简历不论是在排版还是格式上都比较干净，易于阅读。另外，使用 Markdown 写简历也会给面试官一种你比较专业的感觉。</p>
<p>除了这些，我觉得使用 Markdown 写简历可以很方便将其与PDF、HTML、PNG格式之间转换。后面我会介绍到转换方法，只需要一条命令你就可以实现 Markdown 到 PDF、HTML 与 PNG之间的无缝切换。</p>
<blockquote>
<p>下面的一些内容我在之前的一篇文章中已经提到过，这里再说一遍，最后会分享如何实现Markdown 到 PDF、HTML、PNG格式之间转换。</p>
</blockquote>
<h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<h2 id="写简历的两大法则"><a href="#写简历的两大法则" class="headerlink" title="写简历的两大法则"></a>写简历的两大法则</h2><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p>
<p><strong>STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p>
<ul>
<li>Dubbo：精通</li>
<li>Spring：精通</li>
<li>Docker：掌握</li>
<li>SOA分布式开发 ：掌握</li>
<li>Spring Cloud:了解</li>
</ul>
<h2 id="简历模板分享"><a href="#简历模板分享" class="headerlink" title="简历模板分享"></a>简历模板分享</h2><p><strong>开源程序员简历模板</strong>： <a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a>（包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板）</p>
<p><strong>上述简历模板的改进版本：</strong> <a href="https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md</a> </p>
<h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<blockquote>
<p>我们刚刚讲了很多关于如何写简历的内容并且分享了一份 Markdown 格式的简历文档。下面我们来看看如何实现 Markdown 到 HTML格式、PNG格式之间转换。</p>
</blockquote>
<h2 id="Markdown-到-HTML格式、PNG格式之间转换"><a href="#Markdown-到-HTML格式、PNG格式之间转换" class="headerlink" title="Markdown 到 HTML格式、PNG格式之间转换"></a>Markdown 到 HTML格式、PNG格式之间转换</h2><p>网上很难找到一个比较方便并且效果好的转换方法，最后我是通过 Visual Studio Code 的 Markdown PDF 插件完美解决了这个问题！</p>
<h3 id="安装-Markdown-PDF-插件"><a href="#安装-Markdown-PDF-插件" class="headerlink" title="安装 Markdown PDF 插件"></a>安装 Markdown PDF 插件</h3><p><strong>① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9a44103e551?w=1366&h=688&f=png&s=104435" alt="① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项"></p>
<p><strong>② 搜索 “Markdown PDF” 插件并安装 ，然后重启</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9dbef0d06fb?w=1280&h=420&f=png&s=70510" alt="② 搜索 “Markdown PDF” 插件并安装 ，然后重启"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>随便打开一份 Markdown 文件 点击F1，然后输入export即可！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659fa0292906150?w=1289&h=468&f=png&s=72178" alt></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/美团面试常见问题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/美团面试常见问题总结/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->

<ul>
<li><a href="#一-基础篇">一 基础篇</a><ul>
<li><a href="#1-systemoutprintln39输出什么">1. <code>System.out.println(3|9)</code>输出什么?</a></li>
<li><a href="#2-说一下转发forward和重定向redirect的区别">2. 说一下转发(Forward)和重定向(Redirect)的区别</a></li>
<li><a href="#3-在浏览器中输入url地址到显示主页的过程整个过程会使用哪些协议">3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</a></li>
<li><a href="#4-tcp-三次握手和四次挥手">4. TCP 三次握手和四次挥手</a><ul>
<li><a href="#为什么要三次握手">为什么要三次握手</a></li>
<li><a href="#为什么要传回-syn">为什么要传回 SYN</a></li>
<li><a href="#传了-syn为啥还要传-ack">传了 SYN,为啥还要传 ACK</a></li>
<li><a href="#为什么要四次挥手">为什么要四次挥手</a></li>
</ul>
</li>
<li><a href="#5-ip地址与mac地址的区别">5. IP地址与MAC地址的区别</a></li>
<li><a href="#6-http请求响应报文格式">6. HTTP请求,响应报文格式</a></li>
<li><a href="#7-为什么要使用索引索引这么多优点为什么不对表中的每一个列创建一个索引呢索引是如何提高查询速度的说一下使用索引的注意事项mysql索引主要使用的两种数据结构什么是覆盖索引">7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql索引主要使用的两种数据结构?什么是覆盖索引?</a></li>
<li><a href="#8-进程与线程的区别是什么进程间的几种通信方式说一下线程间的几种通信方式知道不">8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?</a></li>
<li><a href="#9-为什么要用单例模式手写几种线程安全的单例模式">9. 为什么要用单例模式?手写几种线程安全的单例模式?</a></li>
<li><a href="#10-简单介绍一下bean知道spring的bean的作用域与生命周期吗">10. 简单介绍一下bean;知道Spring的bean的作用域与生命周期吗?</a></li>
<li><a href="#11-spring-中的事务传播行为了解吗transactiondefinition-接口中哪五个表示隔离级别的常量">11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</a><ul>
<li><a href="#事务传播行为">事务传播行为</a></li>
<li><a href="#隔离级别">隔离级别</a></li>
</ul>
</li>
<li><a href="#12-springmvc-原理了解吗">12. SpringMVC 原理了解吗?</a></li>
<li><a href="#13-spring-aop-ioc-实现原理">13. Spring AOP IOC 实现原理</a></li>
</ul>
</li>
<li><a href="#二-进阶篇">二 进阶篇</a><ul>
<li><a href="#1-消息队列mq的套路">1 消息队列MQ的套路</a><ul>
<li><a href="#11-介绍一下消息队列mq的应用场景使用消息队列的好处">1.1 介绍一下消息队列MQ的应用场景/使用消息队列的好处</a><ul>
<li><a href="#1通过异步处理提高系统性能">1)通过异步处理提高系统性能</a></li>
<li><a href="#2降低系统耦合性">2)降低系统耦合性</a></li>
</ul>
</li>
<li><a href="#12-那么使用消息队列会带来什么问题考虑过这些问题吗">1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?</a></li>
<li><a href="#13-介绍一下你知道哪几种消息队列该如何选择呢">1.3 介绍一下你知道哪几种消息队列,该如何选择呢?</a></li>
<li><a href="#14-关于消息队列其他一些常见的问题展望">1.4 关于消息队列其他一些常见的问题展望</a></li>
</ul>
</li>
<li><a href="#2-谈谈-innodb-和-myisam-两者的区别">2 谈谈 InnoDB 和 MyIsam 两者的区别</a><ul>
<li><a href="#21-两者的对比">2.1 两者的对比</a></li>
<li><a href="#22-关于两者的总结">2.2 关于两者的总结</a></li>
</ul>
</li>
<li><a href="#3-聊聊-java-中的集合吧">3 聊聊 Java 中的集合吧！</a><ul>
<li><a href="#31-arraylist-与-linkedlist-有什么不同注意加上从数据结构分析的内容">3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)</a></li>
<li><a href="#32-hashmap的底层实现">3.2 HashMap的底层实现</a><ul>
<li><a href="#1jdk18之前">1)JDK1.8之前</a></li>
<li><a href="#2jdk18之后">2)JDK1.8之后</a></li>
</ul>
</li>
<li><a href="#33-既然谈到了红黑树你给我手绘一个出来吧然后简单讲一下自己对于红黑树的理解">3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解</a></li>
<li><a href="#34-红黑树这么优秀为何不直接使用红黑树得了">3.4 红黑树这么优秀,为何不直接使用红黑树得了?</a></li>
<li><a href="#35-hashmap-和-hashtable-的区别hashset-和-hashmap-区别">3.5 HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#三-终结篇">三 终结篇</a><ul>
<li><a href="#1-object类有哪些方法">1. Object类有哪些方法?</a><ul>
<li><a href="#11-object类的常见方法总结">1.1 Object类的常见方法总结</a></li>
<li><a href="#12-hashcode与equals">1.2 hashCode与equals</a><ul>
<li><a href="#121-hashcode介绍">1.2.1 hashCode()介绍</a></li>
<li><a href="#122-为什么要有hashcode">1.2.2 为什么要有hashCode</a></li>
<li><a href="#123-hashcode与equals的相关规定">1.2.3 hashCode()与equals()的相关规定</a></li>
<li><a href="#124-为什么两个对象有相同的hashcode值它们也不一定是相等的">1.2.4 为什么两个对象有相同的hashcode值,它们也不一定是相等的?</a></li>
</ul>
</li>
<li><a href="#13-与equals">1.3  ==与equals</a></li>
</ul>
</li>
<li><a href="#2-concurrenthashmap-相关问题">2 ConcurrentHashMap 相关问题</a><ul>
<li><a href="#21-concurrenthashmap-和-hashtable-的区别">2.1 ConcurrentHashMap 和 Hashtable 的区别</a></li>
<li><a href="#22-concurrenthashmap线程安全的具体实现方式底层具体实现">2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</a><ul>
<li><a href="#jdk17上面有示意图">JDK1.7(上面有示意图)</a></li>
<li><a href="#jdk18上面有示意图">JDK1.8(上面有示意图)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-谈谈-synchronized-和-reentrantlock-的区别">3 谈谈 synchronized 和 ReenTrantLock 的区别</a></li>
<li><a href="#4-线程池了解吗">4 线程池了解吗?</a><ul>
<li><a href="#41-为什么要用线程池">4.1 为什么要用线程池?</a></li>
<li><a href="#42-java-提供了哪几种线程池他们各自的使用场景是什么">4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?</a><ul>
<li><a href="#java-主要提供了下面4种线程池">Java 主要提供了下面4种线程池</a></li>
<li><a href="#各种线程池的适用场景介绍">各种线程池的适用场景介绍</a></li>
</ul>
</li>
<li><a href="#43-创建的线程池的方式">4.3 创建的线程池的方式</a></li>
</ul>
</li>
<li><a href="#5-nginx">5 Nginx</a><ul>
<li><a href="#51-简单介绍一下nginx">5.1 简单介绍一下Nginx</a><ul>
<li><a href="#反向代理">反向代理</a></li>
<li><a href="#负载均衡">负载均衡</a></li>
<li><a href="#动静分离">动静分离</a></li>
</ul>
</li>
<li><a href="#52-为什么要用-nginx">5.2 为什么要用 Nginx?</a></li>
<li><a href="#53-nginx-的四个主要组成部分了解吗">5.3  Nginx 的四个主要组成部分了解吗?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->


<p>这些问题是2018年去美团面试的同学被问到的一些常见的问题，希望对你有帮助！</p>
<h1 id="一-基础篇"><a href="#一-基础篇" class="headerlink" title="一 基础篇"></a>一 基础篇</h1><h2 id="1-System-out-println-3-9-输出什么"><a href="#1-System-out-println-3-9-输出什么" class="headerlink" title="1. System.out.println(3|9)输出什么?"></a>1. <code>System.out.println(3|9)</code>输出什么?</h2><p>正确答案：11。</p>
<p><strong>考察知识点：&amp;和&amp;&amp;；|和||</strong></p>
<p><strong>&amp;和&amp;&amp;：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；</p>
<p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。</p>
<p><strong>|和||：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false；</p>
<p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。</p>
<p><strong>回到本题：</strong></p>
<p>3 | 9=0011（二进制） | 1001（二进制）=1011（二进制）=11（十进制）</p>
<h2 id="2-说一下转发-Forward-和重定向-Redirect-的区别"><a href="#2-说一下转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="2. 说一下转发(Forward)和重定向(Redirect)的区别"></a>2. 说一下转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forword）</strong> 通过RequestDispatcher对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure>

<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><strong>从地址栏显示来说</strong>：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的URL。</li>
<li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享request里面的数据。redirect：不能共享数据。</li>
<li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li>
<li><strong>从效率来说</strong>：forward：高。redirect：低。</li>
</ol>
<h2 id="3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议"><a href="#3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议"></a>3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</h2><p>图片来源：《图解HTTP》：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="状态码"></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h2 id="4-TCP-三次握手和四次挥手"><a href="#4-TCP-三次握手和四次挥手" class="headerlink" title="4. TCP 三次握手和四次挥手"></a>4. TCP 三次握手和四次挥手</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p><strong>漫画图解：</strong></p>
<p>图片来源：《图解HTTP》<br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&h=439&f=png&s=226095" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&h=427&f=jpeg&s=15088" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&h=340&f=jpeg&s=13406" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h2 id="5-IP地址与MAC地址的区别"><a href="#5-IP地址与MAC地址的区别" class="headerlink" title="5. IP地址与MAC地址的区别"></a>5. IP地址与MAC地址的区别</h2><p>参考：<a href="https://blog.csdn.net/guoweimelon/article/details/50858597" target="_blank" rel="noopener">https://blog.csdn.net/guoweimelon/article/details/50858597</a></p>
<p>IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<p>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。</p>
<h2 id="6-HTTP请求-响应报文格式"><a href="#6-HTTP请求-响应报文格式" class="headerlink" title="6. HTTP请求,响应报文格式"></a>6. HTTP请求,响应报文格式</h2><p>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成</p>
<p>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成</p>
<p>详细内容可以参考：<a href="https://blog.csdn.net/a19881029/article/details/14002273" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/14002273</a></p>
<h2 id="7-为什么要使用索引-索引这么多优点-为什么不对表中的每一个列创建一个索引呢-索引是如何提高查询速度的-说一下使用索引的注意事项-Mysql索引主要使用的两种数据结构-什么是覆盖索引"><a href="#7-为什么要使用索引-索引这么多优点-为什么不对表中的每一个列创建一个索引呢-索引是如何提高查询速度的-说一下使用索引的注意事项-Mysql索引主要使用的两种数据结构-什么是覆盖索引" class="headerlink" title="7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql索引主要使用的两种数据结构?什么是覆盖索引?"></a>7. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注意事项?Mysql索引主要使用的两种数据结构?什么是覆盖索引?</h2><p><strong>为什么要使用索引？</strong></p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 </li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
<p><strong>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</strong></p>
<ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 </li>
</ol>
<p><strong>索引是如何提高查询速度的？</strong></p>
<p>将无序的数据变成相对有序的数据（就像查目录一样）</p>
<p><strong>说一下使用索引的注意事项</strong></p>
<ol>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ol>
<p><strong>Mysql索引主要使用的哪两种数据结构？</strong></p>
<ul>
<li>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
<li>BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</li>
</ul>
<p>更多关于索引的内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484486&idx=1&sn=215450f11e042bca8a58eac9f4a97686&chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&token=1990180468&lang=zh_CN#rd" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a></p>
<p><strong>什么是覆盖索引?</strong></p>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h2 id="8-进程与线程的区别是什么-进程间的几种通信方式说一下-线程间的几种通信方式知道不"><a href="#8-进程与线程的区别是什么-进程间的几种通信方式说一下-线程间的几种通信方式知道不" class="headerlink" title="8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?"></a>8. 进程与线程的区别是什么?进程间的几种通信方式说一下?线程间的几种通信方式知道不?</h2><p> <strong>进程与线程的区别是什么？</strong></p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p>
<p><strong>进程间的几种通信方式说一下？</strong></p>
<ol>
<li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li>
<li><strong>信号量（semophore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li>
<li><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li>
<li><strong>共享内存（shared memory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字（socket）</strong>：socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</li>
</ol>
<p><strong>线程间的几种通信方式知道不？</strong></p>
<p>1、锁机制</p>
<ul>
<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>
<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>
<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<p>2、信号量机制：包括无名线程信号量与有名线程信号量</p>
<p>3、信号机制：类似于进程间的信号处理。</p>
<p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p>
<h2 id="9-为什么要用单例模式-手写几种线程安全的单例模式"><a href="#9-为什么要用单例模式-手写几种线程安全的单例模式" class="headerlink" title="9. 为什么要用单例模式?手写几种线程安全的单例模式?"></a>9. 为什么要用单例模式?手写几种线程安全的单例模式?</h2><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>懒汉式(双重检查加锁版本)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只有第一次才彻底执行这里的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">               <span class="comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类方式</strong></p>
<p>静态内部实现的单例是懒加载的且线程安全。</p>
<p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-简单介绍一下bean-知道Spring的bean的作用域与生命周期吗"><a href="#10-简单介绍一下bean-知道Spring的bean的作用域与生命周期吗" class="headerlink" title="10. 简单介绍一下bean;知道Spring的bean的作用域与生命周期吗?"></a>10. 简单介绍一下bean;知道Spring的bean的作用域与生命周期吗?</h2><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p>
<p>Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45773d5dd2e?w=563&h=299&f=webp&s=27930" alt="pring的bean的作用域"></p>
<p>Spring的bean的生命周期以及更多内容可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484400&idx=2&sn=7201eb365102fce017f89cb3527fb0bc&chksm=fd985591caefdc872a2fac897288119f94c345e4e12150774f960bf5f816b79e4b9b46be3d7f&token=1990180468&lang=zh_CN#rd" target="_blank" rel="noopener">一文轻松搞懂Spring中bean的作用域与生命周期</a></p>
<h2 id="11-Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量"><a href="#11-Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量" class="headerlink" title="11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?"></a>11. Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</h2><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="12-SpringMVC-原理了解吗"><a href="#12-SpringMVC-原理了解吗" class="headerlink" title="12. SpringMVC 原理了解吗?"></a>12. SpringMVC 原理了解吗?</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45787394192?w=1015&h=466&f=webp&s=35352" alt="SpringMVC 原理"></p>
<p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Model）-&gt;将得到视图对象返回给用户</p>
<p>关于 SpringMVC 原理更多内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484496&idx=1&sn=5472ffa687fe4a05f8900d8ee6726de4&chksm=fd985231caefdb27fc75b44ecf76b6f43e4617e0b01b3c040f8b8fab32e51dfa5118eed1d6ad&token=1990180468&lang=zh_CN#rd" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p>
<h2 id="13-Spring-AOP-IOC-实现原理"><a href="#13-Spring-AOP-IOC-实现原理" class="headerlink" title="13. Spring AOP IOC 实现原理"></a>13. Spring AOP IOC 实现原理</h2><p>过了秋招挺长一段时间了，说实话我自己也忘了如何简要概括 Spring AOP IOC 实现原理，就在网上找了一个较为简洁的答案，下面分享给各位。</p>
<p><strong>IOC：</strong> 控制反转也叫依赖注入。IOC利用java反射机制，AOP利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。</p>
<p><strong>AOP：</strong> 面向切面编程。（Aspect-Oriented Programming） 。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。</p>
<h1 id="二-进阶篇"><a href="#二-进阶篇" class="headerlink" title="二 进阶篇"></a>二 进阶篇</h1><h2 id="1-消息队列MQ的套路"><a href="#1-消息队列MQ的套路" class="headerlink" title="1 消息队列MQ的套路"></a>1 消息队列MQ的套路</h2><p>消息队列/消息中间件应该是Java程序员必备的一个技能了，如果你之前没接触过消息队列的话，建议先去百度一下某某消息队列入门，然后花2个小时就差不多可以学会任何一种消息队列的使用了。如果说仅仅学会使用是万万不够的，在实际生产环境还要考虑消息丢失等等情况。关于消息队列面试相关的问题，推荐大家也可以看一下视频《Java工程师面试突击第1季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p>
<h3 id="1-1-介绍一下消息队列MQ的应用场景-使用消息队列的好处"><a href="#1-1-介绍一下消息队列MQ的应用场景-使用消息队列的好处" class="headerlink" title="1.1 介绍一下消息队列MQ的应用场景/使用消息队列的好处"></a>1.1 介绍一下消息队列MQ的应用场景/使用消息队列的好处</h3><p>面试官一般会先问你这个问题，预热一下，看你知道消息队列不，一般在第一面的时候面试官可能只会问消息队列MQ的应用场景/使用消息队列的好处、使用消息队列会带来什么问题、消息队列的技术选型这几个问题，不会太深究下去，在后面的第二轮/第三轮技术面试中可能会深入问一下。</p>
<p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p>
<h4 id="1-通过异步处理提高系统性能"><a href="#1-通过异步处理提高系统性能" class="headerlink" title="1)通过异步处理提高系统性能"></a>1)通过异步处理提高系统性能</h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e63a8e34ba534?w=910&h=350&f=jpeg&s=29123" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p>
<p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e64583dd3ed01?w=780&h=384&f=jpeg&s=13550" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h4 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2)降低系统耦合性"></a>2)降低系统耦合性</h4><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p>
<blockquote>
<p><strong>先来简单说一下分布式服务：</strong></p>
</blockquote>
<p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>。如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c" target="_blank" rel="noopener">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p>
<blockquote>
<p><strong>再来谈我们的分布式消息队列：</strong></p>
</blockquote>
<p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p>
<p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6665fa394b3b?w=790&h=290&f=jpeg&s=14946" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p>
<blockquote>
<p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p>
</blockquote>
<h3 id="1-2-那么使用消息队列会带来什么问题-考虑过这些问题吗"><a href="#1-2-那么使用消息队列会带来什么问题-考虑过这些问题吗" class="headerlink" title="1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?"></a>1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?</h3><ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<blockquote>
<p>了解下面这个问题是为了我们更好的进行技术选型！该部分摘自：《Java工程师面试突击第1季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p>
</blockquote>
<h3 id="1-3-介绍一下你知道哪几种消息队列-该如何选择呢"><a href="#1-3-介绍一下你知道哪几种消息队列-该如何选择呢" class="headerlink" title="1.3 介绍一下你知道哪几种消息队列,该如何选择呢?"></a>1.3 介绍一下你知道哪几种消息队列,该如何选择呢?</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="right">ActiveMQ</th>
<th align="right">RabbitMQ</th>
<th align="right">RocketMQ</th>
<th align="right">Kafaka</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单机吞吐量</td>
<td align="right">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td align="right">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td align="right">10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td align="right">10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td align="left">topic数量对吞吐量的影响</td>
<td align="right"></td>
<td align="right"></td>
<td align="right">topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td>
<td align="right">topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td align="left">可用性</td>
<td align="right">高，基于主从架构实现高可用性</td>
<td align="right">高，基于主从架构实现高可用性</td>
<td align="right">非常高，分布式架构</td>
<td align="right">非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td align="left">消息可靠性</td>
<td align="right">有较低的概率丢失数据</td>
<td align="right"></td>
<td align="right">经过参数优化配置，可以做到0丢失</td>
<td align="right">经过参数优化配置，消息可以做到0丢失</td>
</tr>
<tr>
<td align="left">时效性</td>
<td align="right">ms级</td>
<td align="right">微秒级，这是rabbitmq的一大特点，延迟是最低的</td>
<td align="right">ms级</td>
<td align="right">延迟在ms级以内</td>
</tr>
<tr>
<td align="left">功能支持</td>
<td align="right">MQ领域的功能极其完备</td>
<td align="right">基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td align="right">MQ功能较为完善，还是分布式的，扩展性好</td>
<td align="right">功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td align="left">优劣势总结</td>
<td align="right">非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td>
<td align="right">erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td>
<td align="right">接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td>
<td align="right">kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</td>
</tr>
</tbody></table>
<blockquote>
<p>这部分内容，我这里不给出答案，大家可以自行根据自己学习的消息队列查阅相关内容，我可能会在后面的文章中介绍到这部分内容。另外，下面这些问题在视频《Java工程师面试突击第1季-中华石杉老师》中都有提到，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p>
</blockquote>
<h3 id="1-4-关于消息队列其他一些常见的问题展望"><a href="#1-4-关于消息队列其他一些常见的问题展望" class="headerlink" title="1.4 关于消息队列其他一些常见的问题展望"></a>1.4 关于消息队列其他一些常见的问题展望</h3><ol>
<li>引入消息队列之后如何保证高可用性？</li>
<li>如何保证消息不被重复消费呢？</li>
<li>如何保证消息的可靠性传输（如何处理消息丢失的问题）？</li>
<li>我该怎么保证从消息队列里拿到的数据按顺序执行？</li>
<li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li>
<li>如果让你来开发一个消息队列中间件，你会怎么设计架构？</li>
</ol>
<h2 id="2-谈谈-InnoDB-和-MyIsam-两者的区别"><a href="#2-谈谈-InnoDB-和-MyIsam-两者的区别" class="headerlink" title="2 谈谈 InnoDB 和 MyIsam 两者的区别"></a>2 谈谈 InnoDB 和 MyIsam 两者的区别</h2><h3 id="2-1-两者的对比"><a href="#2-1-两者的对比" class="headerlink" title="2.1 两者的对比"></a>2.1 两者的对比</h3><ol>
<li><strong>count运算上的区别：</strong> 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存</li>
<li><strong>是否支持事务和崩溃后的安全恢复：</strong> MyISAM 强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。但是 InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
</ol>
<h3 id="2-2-关于两者的总结"><a href="#2-2-关于两者的总结" class="headerlink" title="2.2 关于两者的总结"></a>2.2 关于两者的总结</h3><p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。</p>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。</p>
<h2 id="3-聊聊-Java-中的集合吧"><a href="#3-聊聊-Java-中的集合吧" class="headerlink" title="3 聊聊 Java 中的集合吧!"></a>3 聊聊 Java 中的集合吧!</h2><h3 id="3-1-Arraylist-与-LinkedList-有什么不同-注意加上从数据结构分析的内容"><a href="#3-1-Arraylist-与-LinkedList-有什么不同-注意加上从数据结构分析的内容" class="headerlink" title="3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)"></a>3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)</h3><ul>
<li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（注意双向链表和双向循环链表的区别：）；</li>
<li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1) 而数组为近似 O(n) 。</strong></li>
<li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于<code>get(int index)</code>方法）。</li>
<li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 </li>
</ul>
<p><strong>补充内容:RandomAccess接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 binarySearch() 方法中，它要判断传入的 list 是否RamdomAccess的实例，如果是，调用 indexedBinarySearch() 方法，如果不是，那么调用 iteratorBinarySearch() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1) ，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n) ，所以不支持快速随机访问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！</p>
<p><strong>下面再总结一下 list 的遍历方式选择：</strong></p>
<ul>
<li>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,</li>
<li>未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li>
</ul>
<blockquote>
<p>Java 中的集合这类问题几乎是面试必问的，问到这类问题的时候，HashMap 又是几乎必问的问题，所以大家一定要引起重视！</p>
</blockquote>
<h3 id="3-2-HashMap的底层实现"><a href="#3-2-HashMap的底层实现" class="headerlink" title="3.2 HashMap的底层实现"></a>3.2 HashMap的底层实现</h3><h4 id="1-JDK1-8之前"><a href="#1-JDK1-8之前" class="headerlink" title="1)JDK1.8之前"></a>1)JDK1.8之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991" alt="jdk1.8之前的内部结构"></p>
<h4 id="2-JDK1-8之后"><a href="#2-JDK1-8之后" class="headerlink" title="2)JDK1.8之后"></a>2)JDK1.8之后</h4><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c351da9?w=720&h=545&f=jpeg&s=23933" alt="JDK1.8之后的HashMap底层数据结构"></p>
<p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<blockquote>
<p>问完 HashMap 的底层原理之后，面试官可能就会紧接着问你 HashMap 底层数据结构相关的问题！</p>
</blockquote>
<h3 id="3-3-既然谈到了红黑树-你给我手绘一个出来吧-然后简单讲一下自己对于红黑树的理解"><a href="#3-3-既然谈到了红黑树-你给我手绘一个出来吧-然后简单讲一下自己对于红黑树的理解" class="headerlink" title="3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解"></a>3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑树的理解</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c138cba?w=851&h=614&f=jpeg&s=34458" alt="红黑树"></p>
<p><strong>红黑树特点:</strong></p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ol>
<p><strong>红黑树的应用：</strong></p>
<p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。</p>
<p><strong>为什么要用红黑树</strong></p>
<p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<h3 id="3-4-红黑树这么优秀-为何不直接使用红黑树得了"><a href="#3-4-红黑树这么优秀-为何不直接使用红黑树得了" class="headerlink" title="3.4 红黑树这么优秀,为何不直接使用红黑树得了?"></a>3.4 红黑树这么优秀,为何不直接使用红黑树得了?</h3><p>说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。</p>
<h3 id="3-5-HashMap-和-Hashtable-的区别-HashSet-和-HashMap-区别"><a href="#3-5-HashMap-和-Hashtable-的区别-HashSet-和-HashMap-区别" class="headerlink" title="3.5 HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别"></a>3.5 HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别</h3><p><strong>HashMap 和 Hashtable 的区别</strong></p>
<ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，Hashtable 是线程安全的；Hashtable 内部的方法基本都经过  <code>synchronized</code>  修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 Hashtable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong>   ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p><strong>HashSet 和 HashMap 区别</strong></p>
<p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&h=363&f=jpeg&s=205536" alt="HashSet 和 HashMap 区别"></p>
<h1 id="三-终结篇"><a href="#三-终结篇" class="headerlink" title="三 终结篇"></a>三 终结篇</h1><h2 id="1-Object类有哪些方法"><a href="#1-Object类有哪些方法" class="headerlink" title="1. Object类有哪些方法?"></a>1. Object类有哪些方法?</h2><p>这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握Java这门编程语言，大家都要掌握！</p>
<h3 id="1-1-Object类的常见方法总结"><a href="#1-1-Object类的常见方法总结" class="headerlink" title="1.1 Object类的常见方法总结"></a>1.1 Object类的常见方法总结</h3><p>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode与equals”相关的问题。</p>
</blockquote>
<h3 id="1-2-hashCode与equals"><a href="#1-2-hashCode与equals" class="headerlink" title="1.2 hashCode与equals"></a>1.2 hashCode与equals</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<h4 id="1-2-1-hashCode-介绍"><a href="#1-2-1-hashCode-介绍" class="headerlink" title="1.2.1 hashCode()介绍"></a>1.2.1 hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h4 id="1-2-2-为什么要有hashCode"><a href="#1-2-2-为什么要有hashCode" class="headerlink" title="1.2.2 为什么要有hashCode"></a>1.2.2 为什么要有hashCode</h4><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<h4 id="1-2-3-hashCode-与equals-的相关规定"><a href="#1-2-3-hashCode-与equals-的相关规定" class="headerlink" title="1.2.3 hashCode()与equals()的相关规定"></a>1.2.3 hashCode()与equals()的相关规定</h4><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h4 id="1-2-4-为什么两个对象有相同的hashcode值-它们也不一定是相等的"><a href="#1-2-4-为什么两个对象有相同的hashcode值-它们也不一定是相等的" class="headerlink" title="1.2.4 为什么两个对象有相同的hashcode值,它们也不一定是相等的?"></a>1.2.4 为什么两个对象有相同的hashcode值,它们也不一定是相等的?</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<blockquote>
<p> ==与equals 的对比也是比较常问的基础问题之一！</p>
</blockquote>
<h3 id="1-3-与equals"><a href="#1-3-与equals" class="headerlink" title="1.3  ==与equals"></a>1.3  ==与equals</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String中的equals()方法是被重写过的，因为Object的equals()方法是比较的对象的内存地址，而String的equals()方法比较的是对象的值。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
<blockquote>
<p>在<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484625&idx=1&sn=9c4fa1f7d4291a5fbd7daa44bac2b012&chksm=fd9852b0caefdba6edcf9a827aa4a17ddc97bf6ad2e5ee6f7e1aa1b443b54444d05d2b76732b&token=723699735&lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列5】美团面经总结进阶篇 （附详解答案）</a> 这篇文章中，我们已经提到了一下关于 HashMap 在面试中常见的问题：HashMap 的底层实现、简单讲一下自己对于红黑树的理解、红黑树这么优秀，为何不直接使用红黑树得了、HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别。HashMap 和 ConcurrentHashMap 这俩兄弟在一般只要面试中问到集合相关的问题就一定会被问到，所以各位务必引起重视！</p>
</blockquote>
<h2 id="2-ConcurrentHashMap-相关问题"><a href="#2-ConcurrentHashMap-相关问题" class="headerlink" title="2 ConcurrentHashMap 相关问题"></a>2 ConcurrentHashMap 相关问题</h2><h3 id="2-1-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-1-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.1 ConcurrentHashMap 和 Hashtable 的区别"></a>2.1 ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong>  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong>：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong> </p>
<p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p>
<p>Hashtable：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/50656681.jpg" alt></p>
<p>JDK1.7的ConcurrentHashMap：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/33120488.jpg" alt><br>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点<br>Node: 链表节点）：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/97739220.jpg" alt></p>
<h3 id="2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7-上面有示意图"><a href="#JDK1-7-上面有示意图" class="headerlink" title="JDK1.7(上面有示意图)"></a>JDK1.7(上面有示意图)</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p>Segment 实现了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry  数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<h4 id="JDK1-8-上面有示意图"><a href="#JDK1-8-上面有示意图" class="headerlink" title="JDK1.8(上面有示意图)"></a>JDK1.8(上面有示意图)</h4><p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。</p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h2 id="3-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#3-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="3 谈谈 synchronized 和 ReentrantLock 的区别"></a>3 谈谈 synchronized 和 ReentrantLock 的区别</h2><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。</p>
<p><strong>④ 两者的性能已经相差无几</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReentrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReentrantLock一样，在很多地方都是用到了CAS操作。</p>
<h2 id="4-线程池了解吗"><a href="#4-线程池了解吗" class="headerlink" title="4 线程池了解吗?"></a>4 线程池了解吗?</h2><h3 id="4-1-为什么要用线程池"><a href="#4-1-为什么要用线程池" class="headerlink" title="4.1 为什么要用线程池?"></a>4.1 为什么要用线程池?</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 </p>
<p>这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="4-2-Java-提供了哪几种线程池-他们各自的使用场景是什么"><a href="#4-2-Java-提供了哪几种线程池-他们各自的使用场景是什么" class="headerlink" title="4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?"></a>4.2 Java 提供了哪几种线程池?他们各自的使用场景是什么?</h3><h4 id="Java-主要提供了下面4种线程池"><a href="#Java-主要提供了下面4种线程池" class="headerlink" title="Java 主要提供了下面4种线程池"></a>Java 主要提供了下面4种线程池</h4><ul>
<li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor又分为：ScheduledThreadPoolExecutor（包含多个线程）和SingleThreadScheduledExecutor （只包含一个线程）两种。</li>
</ul>
<h4 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h4><ul>
<li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li>
<li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景；</li>
<li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li>
<li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li>
</ul>
<h3 id="4-3-创建的线程池的方式"><a href="#4-3-创建的线程池的方式" class="headerlink" title="4.3 创建的线程池的方式"></a>4.3 创建的线程池的方式</h3><p><strong>（1） 使用 Executors 创建</strong></p>
<p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用Java提供好的线程池，另外在《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure>

<p><strong>（2） ThreadPoolExecutor的构造函数创建</strong></p>
<p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p>
<p><strong>（3） 使用开源类库</strong></p>
<p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义ThreadPoolExecutor外。还有其他方法。这个时候第一时间就应该想到开源类库，如apache和guava等。”他推荐使用guava提供的ThreadFactoryBuilder来创建线程池。下面是参考他的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p>
<h2 id="5-Nginx"><a href="#5-Nginx" class="headerlink" title="5 Nginx"></a>5 Nginx</h2><h3 id="5-1-简单介绍一下Nginx"><a href="#5-1-简单介绍一下Nginx" class="headerlink" title="5.1 简单介绍一下Nginx"></a>5.1 简单介绍一下Nginx</h3><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 Nginx  主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务。下面我简单地介绍一下这些名词。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>谈到反向代理，就不得不提一下正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了</p>
<ul>
<li><strong>正向代理：</strong>某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的ip和端口号。正向代理比较常见的一个例子就是 VPN 了。</li>
<li><strong>反向代理：</strong> 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</li>
</ul>
<p>通过下面两幅图，大家应该更好理解（图源：<a href="http://blog.720ui.com/2016/nginx_action_05_proxy/）：" target="_blank" rel="noopener">http://blog.720ui.com/2016/nginx_action_05_proxy/）：</a></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/60925795.jpg" alt="正向代理"></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/62563930.jpg" alt="反向代理"></p>
<p>所以，简单的理解，就是正向代理是为客户端做代理，代替客户端去访问服务器，而反向代理是为服务器做代理，代替服务器接受客户端请求。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。</p>
<p>Nginx支持的weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法，感兴趣的可以自行查阅。</p>
<p>负载均衡相比于反向代理更侧重的是将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
<h3 id="5-2-为什么要用-Nginx"><a href="#5-2-为什么要用-Nginx" class="headerlink" title="5.2 为什么要用 Nginx?"></a>5.2 为什么要用 Nginx?</h3><blockquote>
<p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p>
</blockquote>
<p>如果面试官问你这个问题，就一定想看你知道 Nginx 服务器的一些优点吗。</p>
<p>Nginx 有以下5个优点：</p>
<ol>
<li>高并发、高性能（这是其他web服务器不具有的）</li>
<li>可扩展性好（模块化设计，第三方插件生态圈丰富）</li>
<li>高可靠性（可以在服务器行持续不间断的运行数年）</li>
<li>热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx服务的情况下升级 Nginx）</li>
<li>BSD许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）</li>
</ol>
<h3 id="5-3-Nginx-的四个主要组成部分了解吗"><a href="#5-3-Nginx-的四个主要组成部分了解吗" class="headerlink" title="5.3 Nginx 的四个主要组成部分了解吗?"></a>5.3 Nginx 的四个主要组成部分了解吗?</h3><blockquote>
<p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p>
</blockquote>
<ul>
<li>Nginx 二进制可执行文件：由各模块源码编译出一个文件</li>
<li>nginx.conf 配置文件：控制Nginx 行为</li>
<li>acess.log 访问日志： 记录每一条HTTP请求信息</li>
<li>error.log 错误日志：定位问题</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/程序员的简历之道/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/程序员的简历之道/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- TOC -->

<ul>
<li><a href="#程序员简历就该这样写">程序员简历就该这样写</a><ul>
<li><a href="#为什么说简历很重要">为什么说简历很重要？</a><ul>
<li><a href="#先从面试前来说">先从面试前来说</a></li>
<li><a href="#再从面试中来说">再从面试中来说</a></li>
</ul>
</li>
<li><a href="#下面这几点你必须知道">下面这几点你必须知道</a></li>
<li><a href="#必须了解的两大法则">必须了解的两大法则</a><ul>
<li><a href="#star法则situation-task-action-result">STAR法则（Situation Task Action Result）</a></li>
<li><a href="#fab-法则feature-advantage-benefit">FAB 法则（Feature Advantage Benefit）</a></li>
</ul>
</li>
<li><a href="#项目经历怎么写">项目经历怎么写？</a></li>
<li><a href="#专业技能该怎么写">专业技能该怎么写？</a></li>
<li><a href="#排版注意事项">排版注意事项</a></li>
<li><a href="#其他的一些小tips">其他的一些小tips</a></li>
<li><a href="#推荐的工具网站">推荐的工具/网站</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="程序员简历就该这样写"><a href="#程序员简历就该这样写" class="headerlink" title="程序员简历就该这样写"></a>程序员简历就该这样写</h1><p>本篇文章除了教大家用Markdown如何写一份程序员专属的简历，后面还会给大家推荐一些不错的用来写Markdown简历的软件或者网站，以及如何优雅的将Markdown格式转变为PDF格式或者其他格式。</p>
<p>推荐大家使用Markdown语法写简历，然后再将Markdown格式转换为PDF格式后进行简历投递。</p>
<p>如果你对Markdown语法不太了解的话，可以花半个小时简单看一下Markdown语法说明: <a href="http://www.markdown.cn" target="_blank" rel="noopener">http://www.markdown.cn</a> 。</p>
<h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。 在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。为什么说简历很重要呢?</p>
<h3 id="先从面试前来说"><a href="#先从面试前来说" class="headerlink" title="先从面试前来说"></a>先从面试前来说</h3><ul>
<li>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</li>
<li>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</li>
</ul>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<p>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p>
<h3 id="再从面试中来说"><a href="#再从面试中来说" class="headerlink" title="再从面试中来说"></a>再从面试中来说</h3><p>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</p>
<p>所以，首先，你要明确的一点是：<strong>你不会的东西就不要写在简历上</strong>。另外，<strong>你要考虑你该如何才能让你的亮点在简历中凸显出来</strong>，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p>
<p>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</p>
<h2 id="下面这几点你必须知道"><a href="#下面这几点你必须知道" class="headerlink" title="下面这几点你必须知道"></a>下面这几点你必须知道</h2><ol>
<li>大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</li>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</strong></li>
<li><strong>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h2 id="必须了解的两大法则"><a href="#必须了解的两大法则" class="headerlink" title="必须了解的两大法则"></a>必须了解的两大法则</h2><h3 id="STAR法则（Situation-Task-Action-Result）"><a href="#STAR法则（Situation-Task-Action-Result）" class="headerlink" title="STAR法则（Situation Task Action Result）"></a>STAR法则（Situation Task Action Result）</h3><ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<h3 id="FAB-法则（Feature-Advantage-Benefit）"><a href="#FAB-法则（Feature-Advantage-Benefit）" class="headerlink" title="FAB 法则（Feature Advantage Benefit）"></a>FAB 法则（Feature Advantage Benefit）</h3><ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<p>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</p>
<h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写(下面这部分内容摘自我的简历，大家可以根据自己的情况做一些修改和完善)：</p>
<ul>
<li>计算机网络、数据结构、算法、操作系统等课内基础知识：掌握</li>
<li>Java 基础知识：掌握</li>
<li>JVM 虚拟机（Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理）：掌握</li>
<li>高并发、高可用、高性能系统开发：掌握</li>
<li>Struts2、Spring、Hibernate、Ajax、Mybatis、JQuery ：掌握</li>
<li>SSH 整合、SSM 整合、 SOA 架构：掌握</li>
<li>Dubbo： 掌握</li>
<li>Zookeeper: 掌握</li>
<li>常见消息队列: 掌握</li>
<li>Linux：掌握</li>
<li>MySQL常见优化手段：掌握</li>
<li>Spring Boot +Spring Cloud +Docker:了解</li>
<li>Hadoop 生态相关技术中的 HDFS、Storm、MapReduce、Hive、Hbase ：了解</li>
<li>Python 基础、一些常见第三方库比如OpenCV、wxpy、wordcloud、matplotlib：熟悉</li>
</ul>
<h2 id="排版注意事项"><a href="#排版注意事项" class="headerlink" title="排版注意事项"></a>排版注意事项</h2><ol>
<li>尽量简洁，不要太花里胡哨；</li>
<li>一些技术名词不要弄错了大小写比如MySQL不要写成mysql，Java不要写成Java。这个在我看来还是比较忌讳的，所以一定要注意这个细节；</li>
<li>中文和数字英文之间加上空格的话看起来会舒服一点；</li>
</ol>
<h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<h2 id="推荐的工具-网站"><a href="#推荐的工具-网站" class="headerlink" title="推荐的工具/网站"></a>推荐的工具/网站</h2><ul>
<li>冷熊简历(MarkDown在线简历工具，可在线预览、编辑和生成PDF):<a href="http://cv.ftqq.com/" target="_blank" rel="noopener">http://cv.ftqq.com/</a></li>
<li>Typora+<a href="https://github.com/geekcompany/ResumeSample/blob/master/java.md" target="_blank" rel="noopener">Java程序员简历模板</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天我整理了公众号历史所有和面试相关的我觉得还不错的文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485434&idx=1&sn=f6bdf19d2594bf719e149e48d1384340&chksm=cea24831f9d5c1278617d347238f65f0481f36291675f05fabb382b69ea0ff3adae7ee6e6524&token=1452779379&lang=zh_CN#rd" target="_blank" rel="noopener">整理了一些有助于你拿Offer的文章</a> 。今天分享一下最近逛Github看到了一些我觉得对于Java面试以及学习有帮助的仓库，这些仓库涉及Java核心知识点整理、Java常见面试题、算法、基础知识点比如网络和操作系统等等。</p>
<h2 id="知识点相关"><a href="#知识点相关" class="headerlink" title="知识点相关"></a>知识点相关</h2><h3 id="1-JavaGuide"><a href="#1-JavaGuide" class="headerlink" title="1.JavaGuide"></a>1.JavaGuide</h3><ul>
<li>Github地址： <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li>
<li>star: 64.0k</li>
<li>介绍: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</li>
</ul>
<h3 id="2-CS-Notes"><a href="#2-CS-Notes" class="headerlink" title="2.CS-Notes"></a>2.CS-Notes</h3><ul>
<li>Github 地址：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li>
<li>Star:  68.3k </li>
<li>介绍: 技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li>
</ul>
<h3 id="3-advanced-java"><a href="#3-advanced-java" class="headerlink" title="3. advanced-java"></a>3. advanced-java</h3><ul>
<li>Github地址：<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li>
<li>star: 23.4k</li>
<li>介绍: 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习。</li>
</ul>
<h3 id="4-JCSprout"><a href="#4-JCSprout" class="headerlink" title="4.JCSprout"></a>4.JCSprout</h3><ul>
<li>Github地址：<a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">https://github.com/crossoverJie/JCSprout</a></li>
<li>star: 21.2k</li>
<li>介绍: Java Core Sprout：处于萌芽阶段的 Java 核心知识库。</li>
</ul>
<h3 id="5-toBeTopJavaer"><a href="#5-toBeTopJavaer" class="headerlink" title="5.toBeTopJavaer"></a>5.toBeTopJavaer</h3><ul>
<li>Github地址：<a href="https://github.com/hollischuang/toBeTopJavaer" target="_blank" rel="noopener">https://github.com/hollischuang/toBeTopJavaer</a></li>
<li>star: 4.0 k</li>
<li>介绍: Java工程师成神之路。</li>
</ul>
<h3 id="6-architect-awesome"><a href="#6-architect-awesome" class="headerlink" title="6.architect-awesome"></a>6.architect-awesome</h3><ul>
<li>Github地址：<a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">https://github.com/xingshaocheng/architect-awesome</a></li>
<li>star: 34.4 k</li>
<li>介绍:后端架构师技术图谱。</li>
</ul>
<h3 id="7-technology-talk"><a href="#7-technology-talk" class="headerlink" title="7.technology-talk"></a>7.technology-talk</h3><ul>
<li>Github地址： <a href="https://github.com/aalansehaiyang/technology-talk" target="_blank" rel="noopener">https://github.com/aalansehaiyang/technology-talk</a></li>
<li>star: 6.1k</li>
<li>介绍: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识。</li>
</ul>
<h3 id="8-fullstack-tutorial"><a href="#8-fullstack-tutorial" class="headerlink" title="8.fullstack-tutorial"></a>8.fullstack-tutorial</h3><ul>
<li>Github地址： <a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener">https://github.com/frank-lam/fullstack-tutorial</a></li>
<li>star: 4.0k</li>
<li>介绍: fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试。</li>
</ul>
<h3 id="9-3y"><a href="#9-3y" class="headerlink" title="9.3y"></a>9.3y</h3><ul>
<li>Github地址：<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y</a></li>
<li>star: 1.9 k</li>
<li>介绍: Java 知识整合。</li>
</ul>
<h3 id="10-java-bible"><a href="#10-java-bible" class="headerlink" title="10.java-bible"></a>10.java-bible</h3><ul>
<li>Github地址：<a href="https://github.com/biezhi/java-bible" target="_blank" rel="noopener">https://github.com/biezhi/java-bible</a></li>
<li>star: 2.3k</li>
<li>介绍:  这里记录了一些技术摘要，部分文章来自网络，本项目的目的力求分享精品技术干货，以Java为主。</li>
</ul>
<h3 id="11-interviews"><a href="#11-interviews" class="headerlink" title="11.interviews"></a>11.interviews</h3><ul>
<li>Github地址:  <a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md" target="_blank" rel="noopener">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md</a></li>
<li>star: 35.3k</li>
<li>介绍: 软件工程技术面试个人指南（国外的一个项目，虽然有翻译版，但是不太推荐，因为很多内容并不适用于国内）。</li>
</ul>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><h3 id="1-LeetCodeAnimation"><a href="#1-LeetCodeAnimation" class="headerlink" title="1.LeetCodeAnimation"></a>1.LeetCodeAnimation</h3><ul>
<li>Github 地址： <a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation</a></li>
<li>Star:  33.4k</li>
<li>介绍: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路）。</li>
</ul>
<h3 id="2-awesome-java-leetcode"><a href="#2-awesome-java-leetcode" class="headerlink" title="2.awesome-java-leetcode"></a>2.awesome-java-leetcode</h3><ul>
<li>Github地址：<a href="https://github.com/Blankj/awesome-java-leetcode" target="_blank" rel="noopener">https://github.com/Blankj/awesome-java-leetcode</a></li>
<li>star: 6.1k</li>
<li>介绍:  LeetCode 上 Facebook 的面试题目。</li>
</ul>
<h3 id="3-leetcode"><a href="#3-leetcode" class="headerlink" title="3.leetcode"></a>3.leetcode</h3><ul>
<li>Github地址：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a></li>
<li>star: 12.0k</li>
<li>介绍:  LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。)</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/interviewPrepare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/interviewPrepare/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。</p>
<!-- TOC -->

<ul>
<li><a href="#1-如何获取大厂面试机会">1 如何获取大厂面试机会？</a></li>
<li><a href="#2--面试前的准备">2  面试前的准备</a><ul>
<li><a href="#21-准备自己的自我介绍">2.1 准备自己的自我介绍</a></li>
<li><a href="#22-关于着装">2.2 关于着装</a></li>
<li><a href="#23-随身带上自己的成绩单和简历">2.3 随身带上自己的成绩单和简历</a></li>
<li><a href="#24-如果需要笔试就提前刷一些笔试题">2.4 如果需要笔试就提前刷一些笔试题</a></li>
<li><a href="#25-花时间一些逻辑题">2.5 花时间一些逻辑题</a></li>
<li><a href="#26-准备好自己的项目介绍">2.6 准备好自己的项目介绍</a></li>
<li><a href="#27-提前准备技术面试">2.7 提前准备技术面试</a></li>
<li><a href="#27-面试之前做好定向复习">2.7 面试之前做好定向复习</a></li>
</ul>
</li>
<li><a href="#3-面试之后复盘">3 面试之后复盘</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-如何获取大厂面试机会？"><a href="#1-如何获取大厂面试机会？" class="headerlink" title="1 如何获取大厂面试机会？"></a>1 如何获取大厂面试机会？</h2><p><strong>在讲如何获取大厂面试机会之前，先来给大家科普/对比一下两个校招非常常见的概念——春招和秋招。</strong></p>
<ol>
<li><strong>招聘人数</strong> ：秋招多于春招 ；</li>
<li><strong>招聘时间</strong> ： 秋招一般7月左右开始，大概一直持续到10月底。<font color="red">但是大厂（如BAT）都会早开始早结束，所以一定要把握好时间。</font>春招最佳时间为3月，次佳时间为4月，进入5月基本就不会再有春招了（金三银四）。  </li>
<li><strong>应聘难度</strong> ：秋招略大于春招；</li>
<li><strong>招聘公司：</strong>  秋招数量多，而春招数量较少，一般为秋招的补充。 </li>
</ol>
<p><strong>综上，一般来说，秋招的含金量明显是高于春招的。</strong></p>
<p><strong>下面我就说一下我自己知道的一些方法，不过应该也涵盖了大部分获取面试机会的方法。</strong></p>
<ol>
<li><strong>关注大厂官网，随时投递简历（走流程的网申）；</strong></li>
<li><strong>线下参加宣讲会，直接投递简历；</strong></li>
<li><strong>找到师兄师姐/认识的人，帮忙内推（能够让你避开网申简历筛选，笔试筛选，还是挺不错的，不过也还是需要你的简历够棒）；</strong></li>
<li><strong>博客发文被看中/Github优秀开源项目作者，大厂内部人员邀请你面试；</strong></li>
<li><strong>求职类网站投递简历（不是太推荐，适合海投）；</strong></li>
</ol>
<p>除了这些方法，我也遇到过这样的经历：有些大公司的一些部门可能暂时没招够人，然后如果你的亲戚或者朋友刚好在这个公司，而你正好又在寻求offer，那么面试机会基本上是有了，而且这种面试的难度好像一般还普遍比其他正规面试低很多。</p>
<h2 id="2-面试前的准备"><a href="#2-面试前的准备" class="headerlink" title="2  面试前的准备"></a>2  面试前的准备</h2><h3 id="2-1-准备自己的自我介绍"><a href="#2-1-准备自己的自我介绍" class="headerlink" title="2.1 准备自己的自我介绍"></a>2.1 准备自己的自我介绍</h3><p>从HR面、技术面到高管面/部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。</p>
<p>我这里简单分享一下我自己的自我介绍的一个简单的模板吧：</p>
<blockquote>
<p>面试官，您好！我叫某某。大学时间我主要利用课外时间学习某某。在校期间参与过一个某某系统的开发，另外，自己学习过程中也写过很多系统比如某某系统。在学习之余，我比较喜欢通过博客整理分享自己所学知识。我现在是某某社区的认证作者，写过某某很不错的文章。另外，我获得过某某奖,我的Github上开源的某个项目已经有多少Star了。</p>
</blockquote>
<h3 id="2-2-关于着装"><a href="#2-2-关于着装" class="headerlink" title="2.2 关于着装"></a>2.2 关于着装</h3><p>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</p>
<h3 id="2-3-随身带上自己的成绩单和简历"><a href="#2-3-随身带上自己的成绩单和简历" class="headerlink" title="2.3 随身带上自己的成绩单和简历"></a>2.3 随身带上自己的成绩单和简历</h3><p>有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。</p>
<h3 id="2-4-如果需要笔试就提前刷一些笔试题"><a href="#2-4-如果需要笔试就提前刷一些笔试题" class="headerlink" title="2.4 如果需要笔试就提前刷一些笔试题"></a>2.4 如果需要笔试就提前刷一些笔试题</h3><p>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。</p>
<h3 id="2-5-花时间一些逻辑题"><a href="#2-5-花时间一些逻辑题" class="headerlink" title="2.5 花时间一些逻辑题"></a>2.5 花时间一些逻辑题</h3><p>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。</p>
<h3 id="2-6-准备好自己的项目介绍"><a href="#2-6-准备好自己的项目介绍" class="headerlink" title="2.6 准备好自己的项目介绍"></a>2.6 准备好自己的项目介绍</h3><p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p>
<ol>
<li>对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如：用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h3 id="2-7-提前准备技术面试"><a href="#2-7-提前准备技术面试" class="headerlink" title="2.7 提前准备技术面试"></a>2.7 提前准备技术面试</h3><p>搞清楚自己面试中可能涉及哪些知识点、哪些知识点是重点。面试中哪些问题会被经常问到、自己该如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</p>
<h3 id="2-7-面试之前做好定向复习"><a href="#2-7-面试之前做好定向复习" class="headerlink" title="2.7 面试之前做好定向复习"></a>2.7 面试之前做好定向复习</h3><p>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</p>
<p>举个栗子：在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准备，我觉得 20 分钟我很大几率会完不成这项任务。</p>
<h2 id="3-面试之后复盘"><a href="#3-面试之后复盘" class="headerlink" title="3 面试之后复盘"></a>3 面试之后复盘</h2><p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。这个时候很多人内心就会陷入短暂的纠结中：我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？ </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/%E6%97%A0%E5%A5%88.jpg" alt="无奈"></p>
<h3 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h3><p>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。我说这些并不代表你就可以直接对面试官说：“我没问题了。”，笔主当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。面试本身就是一个双向选择的过程，你对这个问题的回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</p>
<p>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化，我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</p>
<p>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</p>
<p>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</p>
<h3 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h3><p>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。总的来说，还是要真诚。除此之外，不要问太 Low 的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不上心，既然你不上心，为什么要要你呢）。举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：</p>
<ul>
<li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li>
<li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li>
<li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li>
<li>……</li>
</ul>
<h3 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h3><p>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</p>
<h4 id="面对HR或者其他Level比较低的面试官时"><a href="#面对HR或者其他Level比较低的面试官时" class="headerlink" title="面对HR或者其他Level比较低的面试官时"></a>面对HR或者其他Level比较低的面试官时</h4><ol>
<li><strong>能不能谈谈你作为一个公司老员工对公司的感受?</strong> (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</li>
<li><strong>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？有什么地方你觉得还不太好或者可以继续完善吗？</strong> （类似第一个问题，都是问面试官个人对于公司的看法。）</li>
<li><strong>我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</li>
<li><strong>接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</strong> （体现出你对工作比较上心，自助学习意识比较强。）</li>
<li><strong>这个岗位为什么还在招人？</strong> (岗位真实性和价值咨询)</li>
<li><strong>大概什么时候能给我回复呢？</strong> (终面的时候，如果面试官没有说的话，可以问一下)</li>
<li>……</li>
</ol>
<h4 id="面对部门领导"><a href="#面对部门领导" class="headerlink" title="面对部门领导"></a>面对部门领导</h4><ol>
<li><strong>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong> </li>
<li><strong>未来如果我要加入这个团队，你对我的期望是什么？</strong> （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</li>
<li><strong>公司对新入职的员工的培养机制是什么样的呢？</strong> （正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</li>
<li><strong>以您来看，这个岗位未来在公司内部的发展如何？</strong> (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</li>
<li><strong>团队现在面临的最大挑战是什么？</strong> (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</li>
</ol>
<h4 id="面对Level比较高的-比如总裁-老板"><a href="#面对Level比较高的-比如总裁-老板" class="headerlink" title="面对Level比较高的(比如总裁,老板)"></a>面对Level比较高的(比如总裁,老板)</h4><ol>
<li><strong>贵公司的发展目标和方向是什么？</strong> （看下公司的发展是否满足自己的期望）</li>
<li><strong>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong> （充分了解自己的优势和劣势）</li>
<li><strong>公司现在面临的最大挑战是什么？</strong></li>
</ol>
<h3 id="来个补充-顺便送个祝福给大家"><a href="#来个补充-顺便送个祝福给大家" class="headerlink" title="来个补充,顺便送个祝福给大家"></a>来个补充,顺便送个祝福给大家</h3><p>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯定是觉得你就是他们要招的人。</p>
<p>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。上面提到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！</p>
<p>金三银四。过了二月就到了面试高峰期或者说是黄金期。几份惊喜几份愁，愿各位能始终不忘初心！每个人都有每个人的难处。引用一句《阿甘正传》里面的台词：“生活就像一盒巧克力，你永远不知道下一块是什么味道“。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/%E7%94%9F%E6%B4%BB%E5%B0%B1%E5%83%8F%E4%B8%80%E7%9B%92%E5%B7%A7%E5%85%8B%E5%8A%9B%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%8B%E4%B8%80%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%B3%E9%81%93.JPEG" alt="加油！彩虹就要来了"></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　身边的朋友或者公众号的粉丝很多人都向我询问过：“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学哪些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指明一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。</p>
<h3 id="Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？"><a href="#Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？" class="headerlink" title="Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？"></a>Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？</h3><p>　　我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。</p>
<p>　　首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。</p>
<p>　　企业HR肯定是更喜欢高学历的人，毕竟985、211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的呢？<br>　　<br>　　双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得了不错的成绩。<strong>一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通过其他的优势来弥补。</strong> 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：<strong>①尽量在面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。</strong></p>
<h3 id="Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？"><a href="#Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？" class="headerlink" title="Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？"></a>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？</h3><p>　　当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果你想进入大厂的话，你也可以通过自己的其他优势来弥补。</p>
<p>　　我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍弃自己本专业的一些学习时间，这是无可厚非的。</p>
<p>　　建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些知识也是一定会被问到的。另外，“一定学好数据结构与算法！一定学好数据结构与算法！一定学好数据结构与算法！”，重要的东西说3遍。</p>
<h3 id="Question3-我没有实习经历的话找工作是不是特别艰难？"><a href="#Question3-我没有实习经历的话找工作是不是特别艰难？" class="headerlink" title="Question3: 我没有实习经历的话找工作是不是特别艰难？"></a>Question3: 我没有实习经历的话找工作是不是特别艰难？</h3><p>　　没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。</p>
<p>　　如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮点，不然，你应该就会被刷。</p>
<h3 id="Question4-我该如何准备面试呢？面试的注意事项有哪些呢？"><a href="#Question4-我该如何准备面试呢？面试的注意事项有哪些呢？" class="headerlink" title="Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？"></a>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？</h3><p>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：</p>
<ol>
<li><strong>准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改</strong>（突出重点，突出自己的优势在哪里，切忌流水账）；</li>
<li><strong>注意随身带上自己的成绩单和简历复印件；</strong> （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。）</li>
<li><strong>如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。</strong>（平时空闲时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞定。</li>
<li><strong>提前准备技术面试。</strong> 搞清楚自己面试中可能涉及哪些知识点、哪些知识点是重点。面试中哪些问题会被经常问到、自己该如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>
<li><strong>面试之前做好定向复习。</strong> 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li>
<li><strong>准备好自己的项目介绍。</strong> 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图）；②在这个项目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如：用 redis 做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
<li><strong>面试之后记得复盘。</strong> 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，不要灰心；如果通过，切勿狂喜。</li>
</ol>
<p><strong>一些还算不错的 Java面试/学习相关的仓库，相信对大家准备面试一定有帮助：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484817&idx=1&sn=12f0c254a240c40c2ccab8314653216b&chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&token=766994974&lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></p>
<h3 id="Question5-我该自学还是报培训班呢？"><a href="#Question5-我该自学还是报培训班呢？" class="headerlink" title="Question5: 我该自学还是报培训班呢？"></a>Question5: 我该自学还是报培训班呢？</h3><p>　　我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。</p>
<p>　　另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。</p>
<p>　　总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。</p>
<h3 id="Question6-没有项目经历-博客-Github开源项目怎么办？"><a href="#Question6-没有项目经历-博客-Github开源项目怎么办？" class="headerlink" title="Question6: 没有项目经历/博客/Github开源项目怎么办？"></a>Question6: 没有项目经历/博客/Github开源项目怎么办？</h3><p>　　从现在开始做！</p>
<p>　　网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相关 Java 后台项目的话，你也可以主动申请参与进来。</p>
<p>　　如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内容、读书笔记等等都可以。</p>
<p>　　多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会收获一个不错的开源项目！</p>
<h3 id="Question7-大厂到底青睐什么样的应届生？"><a href="#Question7-大厂到底青睐什么样的应届生？" class="headerlink" title="Question7: 大厂到底青睐什么样的应届生？"></a>Question7: 大厂到底青睐什么样的应届生？</h3><p>　　从阿里、腾讯等大厂招聘官网对于Java后端方向/后端方向的应届实习生的要求，我们大概可以总结归纳出下面这 4 点能给简历增加很多分数：</p>
<ul>
<li>参加过竞赛（含金量超高的是ACM）；</li>
<li>对数据结构与算法非常熟练；</li>
<li>参与过实际项目（比如学校网站）；</li>
<li>参与过某个知名的开源项目或者自己的某个开源项目很不错；</li>
</ul>
<p>　　除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：</p>
<ul>
<li>熟悉Python、Shell、Perl等脚本语言；</li>
<li>熟悉 Java 优化，JVM调优；</li>
<li>熟悉 SOA 模式；</li>
<li>熟悉自己所用框架的底层知识比如Spring；</li>
<li>了解分布式一些常见的理论；</li>
<li>具备高并发开发经验；大数据开发经验等等。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">syf</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">103</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syf</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
