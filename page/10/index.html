<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>



  <meta property="og:type" content="website">
<meta property="og:title" content="苏有福的博客">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="苏有福的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏有福的博客">





  
  
  <link rel="canonical" href="http://yoursite.com/page/10/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>苏有福的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏有福的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/database/Redis/如何做可靠的分布式锁，Redlock真的可行么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/database/Redis/如何做可靠的分布式锁，Redlock真的可行么/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是对 <a href="https://martin.kleppmann.com/" target="_blank" rel="noopener">Martin Kleppmann</a> 的文章 <a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking</a> 部分内容的翻译和总结，上次写 Redlock 的原因就是看到了 Martin 的这篇文章，写得很好，特此翻译和总结。感兴趣的同学可以翻看原文，相信会收获良多。</p>
<p>开篇作者认为现在 Redis 逐渐被使用到数据管理领域，这个领域需要更强的数据一致性和耐久性，这使得他感到担心，因为这不是 Redis 最初设计的初衷（事实上这也是很多业界程序员的误区，越来越把 Redis 当成数据库在使用），其中基于 Redis 的分布式锁就是令人担心的其一。</p>
<p>Martin 指出首先你要明确你为什么使用分布式锁，为了性能还是正确性？为了帮你区分这二者，在这把锁 fail 了的时候你可以询问自己以下问题： </p>
<ol>
<li><strong>要性能的：</strong> 拥有这把锁使得你不会重复劳动（例如一个 job 做了两次），如果这把锁 fail 了，两个节点同时做了这个 Job，那么这个 Job 增加了你的成本。</li>
<li><strong>要正确性的：</strong> 拥有锁可以防止并发操作污染你的系统或者数据，如果这把锁 fail 了两个节点同时操作了一份数据，结果可能是数据不一致、数据丢失、file 冲突等，会导致严重的后果。</li>
</ol>
<p>上述二者都是需求锁的正确场景，但是你必须清楚自己是因为什么原因需要分布式锁。</p>
<p>如果你只是为了性能，那没必要用 Redlock，它成本高且复杂，你只用一个 Redis 实例也够了，最多加个从防止主挂了。当然，你使用单节点的 Redis 那么断电或者一些情况下，你会丢失锁，但是你的目的只是加速性能且断电这种事情不会经常发生，这并不是什么大问题。并且如果你使用了单节点 Redis，那么很显然你这个应用需要的锁粒度是很模糊粗糙的，也不会是什么重要的服务。</p>
<p>那么是否 Redlock 对于要求正确性的场景就合适呢？Martin 列举了若干场景证明 Redlock 这种算法是不可靠的。</p>
<h2 id="用锁保护资源"><a href="#用锁保护资源" class="headerlink" title="用锁保护资源"></a>用锁保护资源</h2><p>这节里 Martin 先将 Redlock 放在了一边而是仅讨论总体上一个分布式锁是怎么工作的。在分布式环境下，锁比 mutex 这类复杂，因为涉及到不同节点、网络通信并且他们随时可能无征兆的 fail 。<br>Martin 假设了一个场景，一个 client 要修改一个文件，它先申请得到锁，然后修改文件写回，放锁。另一个 client 再申请锁 … 代码流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS CODE IS BROKEN</span></span><br><span class="line"><span class="function">function <span class="title">writeData</span><span class="params">(filename, data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lock = lockService.acquireLock(filename);</span><br><span class="line">    <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Failed to acquire lock'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> file = storage.readFile(filename);</span><br><span class="line">        <span class="keyword">var</span> updated = updateContents(file, data);</span><br><span class="line">        storage.writeFile(filename, updated);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜即使你的锁服务非常完美，上述代码还是可能跪，下面的流程图会告诉你为什么：</p>
<p><img src="https://martin.kleppmann.com/2016/02/unsafe-lock.png" alt></p>
<p>上述图中，得到锁的 client1 在持有锁的期间 pause 了一段时间，例如 GC 停顿。锁有过期时间（一般叫租约，为了防止某个 client 崩溃之后一直占有锁），但是如果 GC 停顿太长超过了锁租约时间，此时锁已经被另一个 client2 所得到，原先的 client1 还没有感知到锁过期，那么奇怪的结果就会发生，曾经 HBase 就发生过这种 Bug。即使你在 client1 写回之前检查一下锁是否过期也无助于解决这个问题，因为 GC 可能在任何时候发生，即使是你非常不便的时候（在最后的检查与写操作期间）。<br>如果你认为自己的程序不会有长时间的 GC 停顿，还有其他原因会导致你的进程 pause。例如进程可能读取尚未进入内存的数据，所以它得到一个 page fault 并且等待 page 被加载进缓存；还有可能你依赖于网络服务；或者其他进程占用 CPU；或者其他人意外发生 SIGSTOP 等。</p>
<p>… …. 这里 Martin 又增加了一节列举各种进程 pause 的例子，为了证明上面的代码是不安全的，无论你的锁服务多完美。</p>
<h2 id="使用-Fencing-（栅栏）使得锁变安全"><a href="#使用-Fencing-（栅栏）使得锁变安全" class="headerlink" title="使用 Fencing （栅栏）使得锁变安全"></a>使用 Fencing （栅栏）使得锁变安全</h2><p>修复问题的方法也很简单：你需要在每次写操作时加入一个 fencing token。这个场景下，fencing token 可以是一个递增的数字（lock service 可以做到），每次有 client 申请锁就递增一次：</p>
<p><img src="https://martin.kleppmann.com/2016/02/fencing-tokens.png" alt></p>
<p>client1 申请锁同时拿到 token33，然后它进入长时间的停顿锁也过期了。client2 得到锁和 token34 写入数据，紧接着 client1 活过来之后尝试写入数据，自身 token33 比 34 小因此写入操作被拒绝。注意这需要存储层来检查 token，但这并不难实现。如果你使用 Zookeeper 作为 lock service 的话那么你可以使用 zxid 作为递增数字。<br>但是对于 Redlock 你要知道，没什么生成 fencing token 的方式，并且怎么修改 Redlock 算法使其能产生 fencing token 呢？好像并不那么显而易见。因为产生 token 需要单调递增，除非在单节点 Redis 上完成但是这又没有高可靠性，你好像需要引进一致性协议来让 Redlock 产生可靠的 fencing token。</p>
<h2 id="使用时间来解决一致性"><a href="#使用时间来解决一致性" class="headerlink" title="使用时间来解决一致性"></a>使用时间来解决一致性</h2><p>Redlock 无法产生 fencing token 早该成为在需求正确性的场景下弃用它的理由，但还有一些值得讨论的地方。</p>
<p>学术界有个说法，算法对时间不做假设：因为进程可能pause一段时间、数据包可能因为网络延迟延后到达、时钟可能根本就是错的。而可靠的算法依旧要在上述假设下做正确的事情。</p>
<p>对于 failure detector 来说，timeout 只能作为猜测某个节点 fail 的依据，因为网络延迟、本地时钟不正确等其他原因的限制。考虑到 Redis 使用 gettimeofday，而不是单调的时钟，会受到系统时间的影响，可能会突然前进或者后退一段时间，这会导致一个 key 更快或更慢地过期。</p>
<p>可见，Redlock 依赖于许多时间假设，它假设所有 Redis 节点都能对同一个 Key 在其过期前持有差不多的时间、跟过期时间相比网络延迟很小、跟过期时间相比进程 pause 很短。</p>
<h2 id="用不可靠的时间打破-Redlock"><a href="#用不可靠的时间打破-Redlock" class="headerlink" title="用不可靠的时间打破 Redlock"></a>用不可靠的时间打破 Redlock</h2><p>这节 Martin 举了个因为时间问题，Redlock 不可靠的例子。</p>
<ol>
<li>client1 从 ABC 三个节点处申请到锁，DE由于网络原因请求没有到达</li>
<li>C节点的时钟往前推了，导致 lock 过期</li>
<li>client2 在CDE处获得了锁，AB由于网络原因请求未到达</li>
<li>此时 client1 和 client2 都获得了锁</li>
</ol>
<p><strong>在 Redlock 官方文档中也提到了这个情况，不过是C崩溃的时候，Redlock 官方本身也是知道 Redlock 算法不是完全可靠的，官方为了解决这种问题建议使用延时启动，相关内容可以看之前的<a href="https://zhuanlan.zhihu.com/p/40915772" target="_blank" rel="noopener">这篇文章</a>。但是 Martin 这里分析得更加全面，指出延时启动不也是依赖于时钟的正确性的么？</strong></p>
<p>接下来 Martin 又列举了进程 Pause 时而不是时钟不可靠时会发生的问题：</p>
<ol>
<li>client1 从 ABCDE 处获得了锁</li>
<li>当获得锁的 response 还没到达 client1 时 client1 进入 GC 停顿</li>
<li>停顿期间锁已经过期了</li>
<li>client2 在 ABCDE 处获得了锁</li>
<li>client1 GC 完成收到了获得锁的 response，此时两个 client 又拿到了同一把锁</li>
</ol>
<p><strong>同时长时间的网络延迟也有可能导致同样的问题。</strong></p>
<h2 id="Redlock-的同步性假设"><a href="#Redlock-的同步性假设" class="headerlink" title="Redlock 的同步性假设"></a>Redlock 的同步性假设</h2><p>这些例子说明了，仅有在你假设了一个同步性系统模型的基础上，Redlock 才能正常工作，也就是系统能满足以下属性：</p>
<ol>
<li>网络延时边界，即假设数据包一定能在某个最大延时之内到达</li>
<li>进程停顿边界，即进程停顿一定在某个最大时间之内</li>
<li>时钟错误边界，即不会从一个坏的 NTP 服务器处取得时间</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Martin 认为 Redlock 实在不是一个好的选择，对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。因为它对高危的时钟或者说其他上述列举的情况进行了不可靠的假设，如果你的应用只需要高性能的分布式锁不要求多高的正确性，那么单节点 Redis 够了；如果你的应用想要保住正确性，那么不建议 Redlock，建议使用一个合适的一致性协调系统，例如 Zookeeper，且保证存在 fencing token。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/数据结构/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面只是简单地总结，给了一些参考文章，后面会对这部分内容进行重构。</p>
<!-- MarkdownTOC -->

<ul>
<li><a href="#queue">Queue</a><ul>
<li><a href="#什么是队列">什么是队列</a></li>
<li><a href="#队列的种类">队列的种类</a></li>
<li><a href="#java-集合框架中的队列-queue">Java 集合框架中的队列 Queue</a></li>
<li><a href="#推荐文章">推荐文章</a></li>
</ul>
</li>
<li><a href="#set">Set</a><ul>
<li><a href="#什么是-set">什么是 Set</a></li>
<li><a href="#补充：有序集合与无序集合说明">补充：有序集合与无序集合说明</a></li>
<li><a href="#hashset-和-treeset-底层数据结构">HashSet 和 TreeSet 底层数据结构</a></li>
<li><a href="#推荐文章-1">推荐文章</a></li>
</ul>
</li>
<li><a href="#list">List</a><ul>
<li><a href="#什么是list">什么是List</a></li>
<li><a href="#list的常见实现类">List的常见实现类</a></li>
<li><a href="#arraylist-和-linkedlist-源码学习">ArrayList 和 LinkedList 源码学习</a></li>
<li><a href="#推荐阅读">推荐阅读</a></li>
</ul>
</li>
<li><a href="#map">Map</a></li>
<li><a href="#树">树</a></li>
</ul>
<!-- /MarkdownTOC -->


<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p>
<h3 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h3><ul>
<li><strong>单队列</strong>（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）</li>
<li><strong>循环队列</strong>（避免了“假溢出”的问题）</li>
</ul>
<h3 id="Java-集合框架中的队列-Queue"><a href="#Java-集合框架中的队列-Queue" class="headerlink" title="Java 集合框架中的队列 Queue"></a>Java 集合框架中的队列 Queue</h3><p>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。<br>Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。<br>除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</p>
<h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><ul>
<li><a href="https://blog.csdn.net/u011240877/article/details/52860924" target="_blank" rel="noopener">Java 集合深入理解（9）：Queue 队列</a></li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="什么是-Set"><a href="#什么是-Set" class="headerlink" title="什么是 Set"></a>什么是 Set</h3><p>Set 继承于 Collection 接口，是一个不允许出现重复元素，并且无序的集合，主要 HashSet 和 TreeSet 两大实现类。</p>
<p>在判断重复元素的时候，Set 集合会调用 hashCode()和 equal()方法来实现。</p>
<h3 id="补充：有序集合与无序集合说明"><a href="#补充：有序集合与无序集合说明" class="headerlink" title="补充：有序集合与无序集合说明"></a>补充：有序集合与无序集合说明</h3><ul>
<li>有序集合：集合里的元素可以根据 key 或 index 访问 (List、Map)</li>
<li>无序集合：集合里的元素只能遍历。（Set）</li>
</ul>
<h3 id="HashSet-和-TreeSet-底层数据结构"><a href="#HashSet-和-TreeSet-底层数据结构" class="headerlink" title="HashSet 和 TreeSet 底层数据结构"></a>HashSet 和 TreeSet 底层数据结构</h3><p><strong>HashSet</strong> 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中的位置；</p>
<p><strong>TreeSet</strong> 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p>
<h3 id="推荐文章-1"><a href="#推荐文章-1" class="headerlink" title="推荐文章"></a>推荐文章</h3><ul>
<li><a href="https://www.jianshu.com/p/b48c47a42916" target="_blank" rel="noopener">Java集合–Set(基础)</a></li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="什么是List"><a href="#什么是List" class="headerlink" title="什么是List"></a>什么是List</h3><p>在 List 中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合而 Set 是无序集合。</p>
<h3 id="List的常见实现类"><a href="#List的常见实现类" class="headerlink" title="List的常见实现类"></a>List的常见实现类</h3><p><strong>ArrayList</strong> 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</p>
<p><strong>LinkedList</strong> 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。</p>
<p><strong>Vector</strong> 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。</p>
<p><strong>Stack</strong> 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。相关阅读：<a href="https://blog.csdn.net/javazejian/article/details/53362993" target="_blank" rel="noopener">java数据结构与算法之栈（Stack）设计与实现</a></p>
<h3 id="ArrayList-和-LinkedList-源码学习"><a href="#ArrayList-和-LinkedList-源码学习" class="headerlink" title="ArrayList 和 LinkedList 源码学习"></a>ArrayList 和 LinkedList 源码学习</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/ArrayList.md" target="_blank" rel="noopener">ArrayList 源码学习</a>    </li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/LinkedList.md" target="_blank" rel="noopener">LinkedList 源码学习</a>   </li>
</ul>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="https://blog.csdn.net/javazejian/article/details/52953190" target="_blank" rel="noopener">java 数据结构与算法之顺序表与链表深入分析</a></li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><a href="https://juejin.im/post/5ab0568b5188255580020e56" target="_blank" rel="noopener">集合框架源码学习之 HashMap(JDK1.8)</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fchengxiao%2Fp%2F6842045.html" target="_blank" rel="noopener">ConcurrentHashMap 实现原理及源码分析</a></li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h3><p> <a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a>（百度百科）</p>
<p>(1)<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">完全二叉树</a>——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p>
<p>(2)<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树</a>——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p>
<p>(3)<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057" target="_blank" rel="noopener">平衡二叉树</a>——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 </p>
</li>
<li><h3 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2 完全二叉树"></a>2 完全二叉树</h3><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">完全二叉树</a>（百度百科）</p>
<p>完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p>
</li>
<li><h3 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="3 满二叉树"></a>3 满二叉树</h3><p> <a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树</a>（百度百科，国内外的定义不同）</p>
<p> 国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p>
</li>
<li><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p> <a href="https://blog.csdn.net/qq_33186366/article/details/51876191" target="_blank" rel="noopener">数据结构之堆的定义</a></p>
<p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
</li>
<li><h3 id="4-二叉查找树（BST）"><a href="#4-二叉查找树（BST）" class="headerlink" title="4 二叉查找树（BST）"></a>4 二叉查找树（BST）</h3><p><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">浅谈算法和数据结构: 七 二叉查找树</a></p>
<p> 二叉查找树的特点：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的     值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点（no duplicate nodes）。</li>
</ol>
</li>
<li><h3 id="5-平衡二叉树（Self-balancing-binary-search-tree）"><a href="#5-平衡二叉树（Self-balancing-binary-search-tree）" class="headerlink" title="5 平衡二叉树（Self-balancing binary search tree）"></a>5 平衡二叉树（Self-balancing binary search tree）</h3><p><a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener"> 平衡二叉树</a>（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）</p>
</li>
<li><h3 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6 红黑树"></a>6 红黑树</h3><ul>
<li><p>红黑树特点:</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
</li>
<li><p>红黑树的应用：</p>
<p>  TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。</p>
</li>
<li><p>为什么要用红黑树</p>
<p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</p>
</li>
<li><p>推荐文章： </p>
<ul>
<li><a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</li>
<li><a href="http://dandanlove.com/2018/03/18/red-black-tree/" target="_blank" rel="noopener">寻找红黑树的操作手册</a>（文章排版以及思路真的不错）</li>
<li><a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener">红黑树深入剖析及Java实现</a>（美团点评技术团队）    </li>
</ul>
</li>
</ul>
</li>
<li><h3 id="7-B-，B-，B-树"><a href="#7-B-，B-，B-树" class="headerlink" title="7 B-，B+，B*树"></a>7 B-，B+，B*树</h3><p> <a href="https://yq.aliyun.com/articles/38345" target="_blank" rel="noopener">二叉树学习笔记之B树、B+树、B*树 </a></p>
<p> <a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">《B-树，B+树，B*树详解》</a></p>
<p> <a href="https://blog.csdn.net/bigtree_3721/article/details/73632405" target="_blank" rel="noopener">《B-树，B+树与B*树的优缺点比较》</a></p>
<p>B-树（或B树）是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance) </p>
<ol>
<li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。</li>
<li>B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</li>
<li>B*树 是B+树的变体，B*树分配新结点的概率比B+树要低，空间使用率更高；</li>
</ol>
</li>
<li><h3 id="8-LSM-树"><a href="#8-LSM-树" class="headerlink" title="8 LSM 树"></a>8 LSM 树</h3><p><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">[HBase] LSM树 VS B+树</a></p>
<p>B+树最大的性能问题是会产生大量的随机IO</p>
<p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p>
<p><a href="http://www.cnblogs.com/yanghuahui/p/3483754.html" target="_blank" rel="noopener">LSM树由来、设计思想以及应用到HBase的索引</a></p>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="BFS及DFS"><a href="#BFS及DFS" class="headerlink" title="BFS及DFS"></a>BFS及DFS</h2><ul>
<li><a href="https://blog.csdn.net/Gene1994/article/details/85097507" target="_blank" rel="noopener">《使用BFS及DFS遍历树和图的思路及实现》</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/算法学习资源推荐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/算法学习资源推荐/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我比较推荐大家可以刷一下 Leetcode ，我自己平时没事也会刷一下，我觉得刷 Leetcode 不仅是为了能让你更从容地面对面试中的手撕算法问题，更可以提高你的编程思维能力、解决问题的能力以及你对某门编程语言 API 的熟练度。当然牛客网也有一些算法题，我下面也整理了一些。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><ul>
<li><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">LeetCode（中国）官网</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/articles/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8-leetcode/" target="_blank" rel="noopener">如何高效地使用 LeetCode</a></p>
</li>
</ul>
<h2 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h2><ul>
<li><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网官网</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">剑指offer编程题</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/ta/2017test" target="_blank" rel="noopener">2017校招真题</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">华为机试题</a></p>
</li>
</ul>
<h2 id="公司真题"><a href="#公司真题" class="headerlink" title="公司真题"></a>公司真题</h2><ul>
<li><a href="https://www.nowcoder.com/test/6910869/summary" target="_blank" rel="noopener"> 网易2018校园招聘编程题真题集合</a></li>
<li><a href="https://www.nowcoder.com/test/6291726/summary" target="_blank" rel="noopener"> 网易2018校招内推编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/5986669/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第五场)编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/5507925/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第四场)编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/5217106/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第三场)编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/4546329/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第二场)编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/4236887/summary" target="_blank" rel="noopener"> 2017年校招全国统一模拟笔试(第一场)编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/4998655/summary" target="_blank" rel="noopener">百度2017春招笔试真题编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/4575457/summary" target="_blank" rel="noopener">网易2017春招笔试真题编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/2811407/summary" target="_blank" rel="noopener">网易2017秋招编程题集合</a></li>
<li><a href="https://www.nowcoder.com/test/2385858/summary" target="_blank" rel="noopener">网易有道2017内推编程题</a></li>
<li><a href="https://www.nowcoder.com/test/3701760/summary" target="_blank" rel="noopener"> 滴滴出行2017秋招笔试真题-编程题汇总</a></li>
<li><a href="https://www.nowcoder.com/test/1725829/summary" target="_blank" rel="noopener">腾讯2017暑期实习生编程题</a></li>
<li><a href="https://www.nowcoder.com/test/1649301/summary" target="_blank" rel="noopener">今日头条2017客户端工程师实习生笔试题</a></li>
<li><a href="https://www.nowcoder.com/test/1649268/summary" target="_blank" rel="noopener">今日头条2017后端工程师实习生笔试题</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/几道常见的子符串算法题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/几道常见的子符串算法题/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->

<ul>
<li><a href="#说明">说明</a></li>
<li><a href="#1-kmp-算法">1. KMP 算法</a></li>
<li><a href="#2-替换空格">2. 替换空格</a></li>
<li><a href="#3-最长公共前缀">3. 最长公共前缀</a></li>
<li><a href="#4-回文串">4. 回文串</a><ul>
<li><a href="#41-最长回文串">4.1. 最长回文串</a></li>
<li><a href="#42-验证回文串">4.2. 验证回文串</a></li>
<li><a href="#43-最长回文子串">4.3. 最长回文子串</a></li>
<li><a href="#44-最长回文子序列">4.4. 最长回文子序列</a></li>
</ul>
</li>
<li><a href="#5-括号匹配深度">5. 括号匹配深度</a></li>
<li><a href="#6-把字符串转换成整数">6. 把字符串转换成整数</a></li>
</ul>
<!-- /MarkdownTOC -->


<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>本文作者：wwwxmu</li>
<li>原文地址:<a href="https://www.weiweiblog.cn/13string/" target="_blank" rel="noopener">https://www.weiweiblog.cn/13string/</a></li>
<li>作者的博客站点：<a href="https://www.weiweiblog.cn/" target="_blank" rel="noopener">https://www.weiweiblog.cn/</a> （推荐哦！）</li>
</ul>
<p>考虑到篇幅问题，我会分两次更新这个内容。本篇文章只是原文的一部分，我在原文的基础上增加了部分内容以及修改了部分代码和注释。另外，我增加了爱奇艺 2018 秋招 Java：<code>求给定合法括号序列的深度</code> 这道题。所有代码均编译成功，并带有注释，欢迎各位享用！</p>
<h2 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h2><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><strong>字符串匹配的KMP算法:</strong> <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></li>
<li><strong>从头到尾彻底理解KMP:</strong> <a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></li>
<li><strong>如何更好的理解和掌握 KMP 算法?:</strong> <a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">https://www.zhihu.com/question/21923021</a></li>
<li><strong>KMP 算法详细解析:</strong>  <a href="https://blog.sengxian.com/algorithms/kmp" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/kmp</a></li>
<li><strong>图解 KMP 算法:</strong> <a href="http://blog.jobbole.com/76611/" target="_blank" rel="noopener">http://blog.jobbole.com/76611/</a></li>
<li><strong>汪都能听懂的KMP字符串匹配算法【双语字幕】:</strong> <a href="https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925" target="_blank" rel="noopener">https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925</a></li>
<li><strong>KMP字符串匹配算法1:</strong> <a href="https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250" target="_blank" rel="noopener">https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250</a></li>
</ul>
<p><strong>除此之外，再来了解一下BM算法！</strong></p>
<blockquote>
<p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。<br>《字符串匹配的KMP算法》:<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
</blockquote>
<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这里我提供了两种方法：①常规方法；②利用 API 解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/replacespace/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "</span></span><br><span class="line"><span class="comment">   * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="comment">// System.out.println("length=" + length);</span></span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> b = str.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">" "</span>)) &#123;</span><br><span class="line">        result.append(<span class="string">"%20"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二种方法：利用API替换掉所用空格，一行代码解决问题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.toString().replaceAll(<span class="string">"\\s"</span>, <span class="string">"%20"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h2><blockquote>
<p>Leetcode:  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p>思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line">		<span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 数组长度</span></span><br><span class="line">		<span class="keyword">int</span> len = strs.length;</span><br><span class="line">		<span class="comment">// 用于保存结果</span></span><br><span class="line">		StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">		Arrays.sort(strs);</span><br><span class="line">		<span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">		<span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line">		<span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">				res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStrs</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strs[i] == <span class="keyword">null</span> || strs[i].length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line">		<span class="comment">// String[] strs = &#123; "customer", "car", null &#125;;//空串</span></span><br><span class="line">		<span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line">		<span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">		System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-回文串"><a href="#4-回文串" class="headerlink" title="4. 回文串"></a>4. 回文串</h2><h3 id="4-1-最长回文串"><a href="#4-1-最长回文串" class="headerlink" title="4.1. 最长回文串"></a>4.1. 最长回文串</h3><blockquote>
<p>LeetCode:  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注<br>意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科  地址：<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</a></p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li>字符出现次数为双数的组合+一个只出现一次的字符</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindrome/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存放字符</span></span><br><span class="line">    HashSet&lt;Character&gt; hashset = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hashset.contains(chars[i])) &#123;<span class="comment">// 如果hashset没有该字符就保存进去</span></span><br><span class="line">        hashset.add(chars[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span></span><br><span class="line">        hashset.remove(chars[i]);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashset.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-验证回文串"><a href="#4-2-验证回文串" class="headerlink" title="4.2. 验证回文串"></a>4.2. 验证回文串</h3><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/valid-palindrome/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="comment">// 从头和尾开始向中间遍历</span></span><br><span class="line">      <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        l++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        r--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断二者是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-最长回文子串"><a href="#4-3-最长回文子串" class="headerlink" title="4.3. 最长回文子串"></a>4.3. 最长回文子串</h3><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。给大家大致花了个草图，不要嫌弃！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc32f6f1833ff?w=723&h=371&f=png&s=9305" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindromic-substring/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index, len;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      PalindromeHelper(s, i, i);</span><br><span class="line">      PalindromeHelper(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(index, index + len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PalindromeHelper</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">      l--;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">      index = l + <span class="number">1</span>;</span><br><span class="line">      len = r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-最长回文子序列"><a href="#4-4-最长回文子序列" class="headerlink" title="4.4. 最长回文子序列"></a>4.4. 最长回文子序列</h3><blockquote>
<p>LeetCode: 最长回文子序列<br>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。<br><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bb”。</p>
<p><strong>动态规划：</strong>  dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-括号匹配深度"><a href="#5-括号匹配深度" class="headerlink" title="5. 括号匹配深度"></a>5. 括号匹配深度</h2><blockquote>
<p>爱奇艺 2018 秋招 Java：<br>一个合法的括号匹配序列有以下定义:</p>
<ol>
<li>空串””是一个合法的括号匹配序列</li>
<li>如果”X”和”Y”都是合法的括号匹配序列,”XY”也是一个合法的括号匹配序列</li>
<li>如果”X”是一个合法的括号匹配序列,那么”(X)”也是一个合法的括号匹配序列</li>
<li>每个合法的括号序列都可以由以上规则生成。</li>
</ol>
</blockquote>
<blockquote>
<p>例如: “”,”()”,”()()”,”((()))”都是合法的括号序列<br>对于一个合法的括号序列我们又有以下定义它的深度:</p>
<ol>
<li>空串””的深度是0</li>
<li>如果字符串”X”的深度是x,字符串”Y”的深度是y,那么字符串”XY”的深度为max(x,y)   </li>
<li>如果”X”的深度是x,那么字符串”(X)”的深度是x+1</li>
</ol>
</blockquote>
<blockquote>
<p>例如: “()()()”的深度是1,”((()))”的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&apos;(&apos;和&apos;)&apos;。</span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思路草图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc6fca94ef278?w=792&h=324&f=png&s=15868" alt></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/test/8246651/summary</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月6日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO 求给定合法括号序列的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String s = sc.nextLine();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, max = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cnt--;</span><br><span class="line">      max = Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-把字符串转换成整数"><a href="#6-把字符串转换成整数" class="headerlink" title="6. 把字符串转换成整数"></a>6. 把字符串转换成整数</h2><blockquote>
<p>剑指offer:  将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/strtoint/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="comment">// 判断是否存在符号位</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">      flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> start = flag &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;<span class="comment">// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span></span><br><span class="line">        <span class="keyword">int</span> temp = chars[i] - <span class="string">'0'</span>;</span><br><span class="line">        res = res * <span class="number">10</span> + temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span> ? res : -res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    String s = <span class="string">"-12312312"</span>;</span><br><span class="line">    System.out.println(<span class="string">"使用库函数转换："</span> + Integer.valueOf(s));</span><br><span class="line">    <span class="keyword">int</span> res = Main.StrToInt(s);</span><br><span class="line">    System.out.println(<span class="string">"使用自己写的方法转换："</span> + res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/几道常见的链表算法题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/几道常见的链表算法题/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->

<ul>
<li><a href="#1-两数相加">1. 两数相加</a><ul>
<li><a href="#题目描述">题目描述</a></li>
<li><a href="#问题分析">问题分析</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#2-翻转链表">2. 翻转链表</a><ul>
<li><a href="#题目描述-1">题目描述</a></li>
<li><a href="#问题分析-1">问题分析</a></li>
<li><a href="#solution-1">Solution</a></li>
</ul>
</li>
<li><a href="#3-链表中倒数第k个节点">3. 链表中倒数第k个节点</a><ul>
<li><a href="#题目描述-2">题目描述</a></li>
<li><a href="#问题分析-2">问题分析</a></li>
<li><a href="#solution-2">Solution</a></li>
</ul>
</li>
<li><a href="#4-删除链表的倒数第n个节点">4. 删除链表的倒数第N个节点</a><ul>
<li><a href="#问题分析-3">问题分析</a></li>
<li><a href="#solution-3">Solution</a></li>
</ul>
</li>
<li><a href="#5-合并两个排序的链表">5. 合并两个排序的链表</a><ul>
<li><a href="#题目描述-3">题目描述</a></li>
<li><a href="#问题分析-4">问题分析</a></li>
<li><a href="#solution-4">Solution</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->


<h1 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1. 两数相加"></a>1. 两数相加</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>Leetcode官方详细解答地址：</p>
<p> <a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/</a></p>
<blockquote>
<p>要对头结点进行操作时，考虑创建哑节点dummy，使用dummy-&gt;next表示真正的头节点。这样可以避免处理头节点为空的边界问题。</p>
</blockquote>
<p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐<br>位相加的过程。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。"></p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>我们首先从最低有效位也就是列表 l1和 l2 的表头开始相加。注意需要考虑到进位的情况！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//https://leetcode-cn.com/problems/add-two-numbers/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="comment">//carry 表示进位数</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        <span class="comment">//进位数</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//新节点的数值为sum % 10</span></span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-翻转链表"><a href="#2-翻转链表" class="headerlink" title="2. 翻转链表"></a>2. 翻转链表</h1><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/81431871.jpg" alt="翻转链表"></p>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月19日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存要反转到头的那个节点</span></span><br><span class="line">      next = head.next;</span><br><span class="line">      <span class="comment">// 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)</span></span><br><span class="line">      head.next = pre;</span><br><span class="line">      <span class="comment">// 上一个已经反转到头部的节点</span></span><br><span class="line">      pre = head;</span><br><span class="line">      <span class="comment">// 一直向链表尾走</span></span><br><span class="line">      head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ListNode a = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">  ListNode b = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">  ListNode c = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">  ListNode d = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">  ListNode e = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">  a.next = b;</span><br><span class="line">  b.next = c;</span><br><span class="line">  c.next = d;</span><br><span class="line">  d.next = e;</span><br><span class="line">  <span class="keyword">new</span> Solution().ReverseList(a);</span><br><span class="line">  <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(e.val);</span><br><span class="line">    e = e.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="3-链表中倒数第k个节点"><a href="#3-链表中倒数第k个节点" class="headerlink" title="3. 链表中倒数第k个节点"></a>3. 链表中倒数第k个节点</h1><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote>
<p><strong>链表中倒数第k个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！</strong></p>
</blockquote>
<p>首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(n),一次遍历即可</span></span><br><span class="line"><span class="comment">// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果链表为空或者k小于等于0</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明两个指向头结点的节点</span></span><br><span class="line">    ListNode node1 = head, node2 = head;</span><br><span class="line">    <span class="comment">// 记录节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录k值，后面要使用</span></span><br><span class="line">    <span class="keyword">int</span> index = k;</span><br><span class="line">    <span class="comment">// p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，</span></span><br><span class="line">    <span class="comment">// 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点</span></span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node1 = node1.next;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span> (k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点个数小于所求的倒数第k个节点，则返回空</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; index)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-删除链表的倒数第N个节点"><a href="#4-删除链表的倒数第N个节点" class="headerlink" title="4. 删除链表的倒数第N个节点"></a>4. 删除链表的倒数第N个节点</h1><blockquote>
<p>Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>该题在 leetcode 上有详细解答，具体可参考 Leetcode.</p>
<h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/94354387.jpg" alt="图 1. 删除列表中的第 L - n + 1 个元素"></p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p><strong>两次遍历法</strong></p>
<p>首先我们将添加一个 <strong>哑结点</strong> 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。<strong>我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 哑结点指向头结点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 保存链表长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode len = head;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="keyword">null</span>) &#123;</span><br><span class="line">      length++;</span><br><span class="line">      len = len.next;</span><br><span class="line">    &#125;</span><br><span class="line">    length = length - n;</span><br><span class="line">    ListNode target = dummy;</span><br><span class="line">    <span class="comment">// 找到 L-n 位置的节点</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      target = target.next;</span><br><span class="line">      length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点</span></span><br><span class="line">    target.next = target.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(L)</strong> ：该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)(L−n) 个结点。 操作执行了 2L-n2L−n 步，时间复杂度为 O(L)O(L)。</li>
<li><strong>空间复杂度 O(1)</strong> ：我们只用了常量级的额外空间。 </li>
</ul>
<p><strong>进阶——一次遍历法：</strong></p>
<blockquote>
<p>**链表中倒数第N个节点也就是正数第(L-N+1)个节点。</p>
</blockquote>
<p>其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。<strong>基本思路就是：</strong>  定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 声明两个指向头结点的节点</span></span><br><span class="line">    ListNode node1 = dummy, node2 = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑</span></span><br><span class="line">    <span class="comment">// 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）</span></span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node1 = node1.next;</span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">1</span> &amp;&amp; node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node2.next = node2.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-合并两个排序的链表"><a href="#5-合并两个排序的链表" class="headerlink" title="5. 合并两个排序的链表"></a>5. 合并两个排序的链表</h1><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>剑指offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<h3 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们可以这样分析: </p>
<ol>
<li>假设我们有两个链表 A,B； </li>
<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点； </li>
<li>A2再和B1比较，假设B1小,则，A1指向B1； </li>
<li>A2再和B2比较<br>就这样循环往复就行了，应该还算好理解。</li>
</ol>
<p>考虑通过递归的方式实现！</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p><strong>递归版本：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">           list1.next = Merge(list1.next, list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           list2.next = Merge(list1, list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/公司真题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/公司真题/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网易-2018"><a href="#网易-2018" class="headerlink" title="网易 2018"></a>网易 2018</h1><p>下面三道编程题来自网易2018校招编程题，这三道应该来说是非常简单的编程题了，这些题目大家稍微有点编程和数学基础的话应该没什么问题。看答案之前一定要自己先想一下如果是自己做的话会怎么去做，然后再对照这我的答案看看，和你自己想的有什么区别？那一种方法更好？</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="一-获得特定数量硬币问题"><a href="#一-获得特定数量硬币问题" class="headerlink" title="一 获得特定数量硬币问题"></a>一 获得特定数量硬币问题</h3><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。</p>
<p>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币</p>
<p>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币</p>
<p>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 </p>
<p><strong>输入描述:</strong> 输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。</p>
<p><strong>输出描述:</strong> 输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符’1’和’2’。</p>
<p><strong>输入例子1:</strong> 10</p>
<p><strong>输出例子1:</strong> 122</p>
<h3 id="二-求“相反数”问题"><a href="#二-求“相反数”问题" class="headerlink" title="二 求“相反数”问题"></a>二 求“相反数”问题</h3><p>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. </p>
<p><strong>输入描述:</strong> 输入包括一个整数n,(1 ≤ n ≤ 10^5)</p>
<p><strong>输出描述:</strong> 输出一个整数,表示n的相反数</p>
<p><strong>输入例子1:</strong> 1325</p>
<p><strong>输出例子1:</strong> 6556</p>
<h3 id="三-字符串碎片的平均长度"><a href="#三-字符串碎片的平均长度" class="headerlink" title="三 字符串碎片的平均长度"></a>三 字符串碎片的平均长度</h3><p>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。</p>
<p><strong>输入描述:</strong> 输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母(‘a’-‘z’)</p>
<p><strong>输出描述:</strong> 输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</p>
<p><strong>如样例所示:</strong> s = “aaabbaaac”<br>所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25</p>
<p><strong>输入例子1:</strong> aaabbaaac</p>
<p><strong>输出例子1:</strong> 2.25</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="一-获得特定数量硬币问题-1"><a href="#一-获得特定数量硬币问题-1" class="headerlink" title="一 获得特定数量硬币问题"></a>一 获得特定数量硬币问题</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>作为该试卷的第一题，这道题应该只要思路正确就很简单了。</p>
<p>解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>注意：由于用户的输入不确定性，一般是为了程序高可用性使需要将捕获用户输入异常然后友好提示用户输入类型错误并重新输入的。所以下面我给了两个版本，这两个版本都是正确的。这里只是给大家演示如何捕获输入类型异常，后面的题目中我给的代码没有异常处理的部分，参照下面两个示例代码，应该很容易添加。（PS：企业面试中没有明确就不用添加异常处理，当然你有的话也更好）</p>
<p><strong>不带输入异常处理判断的版本：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"请输入要获得的硬币数量："</span>);</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> coincount = scanner.nextInt();</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">while</span> (coincount &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 偶数的情况</span></span><br><span class="line">			<span class="keyword">if</span> (coincount % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				coincount = (coincount - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">				sb.append(<span class="string">"2"</span>);</span><br><span class="line">				<span class="comment">// 奇数的情况</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				coincount = (coincount - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">				sb.append(<span class="string">"1"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出反转后的字符串</span></span><br><span class="line">		System.out.println(sb.reverse());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带输入异常处理判断的版本（当输入的不是整数的时候会提示重新输入）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"请输入要获得的硬币数量："</span>);</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> coincount = scanner.nextInt();</span><br><span class="line">				StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">				<span class="keyword">while</span> (coincount &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 偶数的情况</span></span><br><span class="line">					<span class="keyword">if</span> (coincount % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">						coincount = (coincount - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">						sb.append(<span class="string">"2"</span>);</span><br><span class="line">						<span class="comment">// 奇数的情况</span></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						coincount = (coincount - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">						sb.append(<span class="string">"1"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 输出反转后的字符串</span></span><br><span class="line">				System.out.println(sb.reverse());</span><br><span class="line">				flag=<span class="keyword">false</span>;<span class="comment">//程序结束</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"输入数据类型不匹配，请您重新输入:"</span>);</span><br><span class="line">				scanner.nextLine();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-求“相反数”问题-1"><a href="#二-求“相反数”问题-1" class="headerlink" title="二 求“相反数”问题"></a>二 求“相反数”问题</h3><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p>解决本道题有几种不同的方法，但是最快速的方法就是利用reverse()方法反转字符串然后再将字符串转换成int类型的整数，这个方法是快速解决本题关键。我们先来回顾一下下面两个知识点：</p>
<p><strong>1)String转int；</strong></p>
<p>在 Java 中要将 String 类型转化为 int 类型时,需要使用 Integer 类中的 parseInt() 方法或者 valueOf() 方法进行转换.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(str);</span><br></pre></td></tr></table></figure>

<p> 或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.valueOf(str).intValue()；</span><br></pre></td></tr></table></figure>

<p><strong>2)next()和nextLine()的区别</strong></p>
<p>在Java中输入字符串有两种方法，就是next()和nextLine().两者的区别就是：nextLine()的输入是碰到回车就终止输入，而next()方法是碰到空格，回车，Tab键都会被视为终止符。所以next()不会得到带空格的字符串，而nextLine()可以得到带空格的字符串。</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本题关键：①String转int；②next()和nextLine()的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"请输入一个整数："</span>);</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String s=scanner.next(); </span><br><span class="line">		<span class="comment">//将字符串转换成数字</span></span><br><span class="line">		<span class="keyword">int</span> number1=Integer.parseInt(s);</span><br><span class="line">		<span class="comment">//将字符串倒序后转换成数字</span></span><br><span class="line">		<span class="comment">//因为Integer.parseInt()的参数类型必须是字符串所以必须加上toString()</span></span><br><span class="line">		<span class="keyword">int</span> number2=Integer.parseInt(<span class="keyword">new</span> StringBuilder(s).reverse().toString());</span><br><span class="line">		System.out.println(number1+number2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-字符串碎片的平均长度-1"><a href="#三-字符串碎片的平均长度-1" class="headerlink" title="三 字符串碎片的平均长度"></a>三 字符串碎片的平均长度</h3><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h4><p>这道题的意思也就是要求：(字符串的总长度)/(相同字母团构成的字符串的个数)。</p>
<p>这样就很简单了，就变成了字符串的字符之间的比较。如果需要比较字符串的字符的话，我们可以利用charAt(i)方法：取出特定位置的字符与后一个字符比较，或者利用toCharArray()方法将字符串转换成字符数组采用同样的方法做比较。</p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p><strong>利用charAt(i)方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">	        String s = sc.next();</span><br><span class="line">	        <span class="comment">//个数至少为一个</span></span><br><span class="line">	        <span class="keyword">float</span> count = <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (s.charAt(i) != s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">	                count++;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println(s.length() / count);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用toCharArray()方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">	        String s = sc.next();</span><br><span class="line">	        <span class="comment">//个数至少为一个</span></span><br><span class="line">	        <span class="keyword">float</span> count = <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">char</span> [] stringArr = s.toCharArray();</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringArr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (stringArr[i] != stringArr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">	                count++;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println(s.length() / count);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/dataStructures-algorithms/Backtracking-NQueens/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/dataStructures-algorithms/Backtracking-NQueens/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/03/26/ANUzjA.png" alt="ANUzjA.png"></p>
<blockquote>
</blockquote>
<p>上图为 8 皇后问题的一种解法。</p>
<blockquote>
</blockquote>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<blockquote>
</blockquote>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>约束条件为每个棋子所在的行、列、对角线都不能有另一个棋子。</p>
<p>使用一维数组表示一种解法，下标（index）表示行，值（value）表示该行的Q（皇后）在哪一列。<br>每行只存储一个元素，然后递归到下一行，这样就不用判断行了，只需要判断列和对角线。</p>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>当result[row] = column时，即row行的棋子在column列。</p>
<p>对于[0, row-1]的任意一行（i 行），若 row 行的棋子和 i 行的棋子在同一列，则有result[i] == column;<br>若 row 行的棋子和 i 行的棋子在同一对角线，等腰直角三角形两直角边相等，即 row - i == Math.abs(result[i] - column)</p>
<p>布尔类型变量 isValid 的作用是剪枝，减少不必要的递归。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">	// 下标代表行，值代表列。如result[0] = 3 表示第1行的Q在第3列</span><br><span class="line">	int[] result = new int[n];</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; resultList = new LinkedList&lt;&gt;();</span><br><span class="line">	dfs(resultList, result, 0, n);</span><br><span class="line">	return resultList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(List&lt;List&lt;String&gt;&gt; resultList, int[] result, int row, int n) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">	if (row == n) &#123;</span><br><span class="line">		List&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">		for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">			StringBuilder sb = new StringBuilder();</span><br><span class="line">			for (int y = 0; y &lt; n; ++y)</span><br><span class="line">				sb.append(result[x] == y ? &quot;Q&quot; : &quot;.&quot;);</span><br><span class="line">			list.add(sb.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		resultList.add(list);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int column = 0; column &lt; n; ++column) &#123;</span><br><span class="line">		boolean isValid = true;</span><br><span class="line">		result[row] = column;</span><br><span class="line">		/*</span><br><span class="line">		 * 逐行往下考察每一行。同列，result[i] == column</span><br><span class="line">		 * 同对角线，row - i == Math.abs(result[i] - column)</span><br><span class="line">		 */</span><br><span class="line">		for (int i = row - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">			if (result[i] == column || row - i == Math.abs(result[i] - column)) &#123;</span><br><span class="line">				isValid = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (isValid) dfs(resultList, result, row + 1, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>使用LinkedList表示一种解法，下标（index）表示行，值（value）表示该行的Q（皇后）在哪一列。</p>
<p>解法二和解法一的不同在于，相同列以及相同对角线的校验。<br>将对角线抽象成【一次函数】这个简单的数学模型，根据一次函数的截距是常量这一特性进行校验。</p>
<p>这里，我将右上-左下对角线，简称为“\”对角线；左上-右下对角线简称为“/”对角线。</p>
<p>“/”对角线斜率为1，对应方程为y = x + b，其中b为截距。<br>对于线上任意一点，均有y - x = b，即row - i = b;<br>定义一个布尔类型数组anti_diag，将b作为下标，当anti_diag[b] = true时，表示相应对角线上已经放置棋子。<br>但row - i有可能为负数，负数不能作为数组下标，row - i 的最小值为-n（当row = 0，i = n时），可以加上n作为数组下标，即将row -i + n 作为数组下标。<br>row - i + n 的最大值为 2n（当row = n，i = 0时），故anti_diag的容量设置为 2n 即可。</p>
<p><img src="https://s2.ax1x.com/2019/03/26/ANXG79.png" alt="ANXG79.png"></p>
<p>“\”对角线斜率为-1，对应方程为y = -x + b，其中b为截距。<br>对于线上任意一点，均有y + x = b，即row + i = b;<br>同理，定义数组main_diag，将b作为下标，当main_diag[row + i] = true时，表示相应对角线上已经放置棋子。</p>
<p>有了两个校验对角线的数组，再来定义一个用于校验列的数组cols，这个太简单啦，不解释。</p>
<p><strong>解法二时间复杂度为O(n!)，在校验相同列和相同对角线时，引入三个布尔类型数组进行判断。相比解法一，少了一层循环，用空间换时间。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; resultList = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">	boolean[] cols = new boolean[n];</span><br><span class="line">	boolean[] main_diag = new boolean[2 * n];</span><br><span class="line">	boolean[] anti_diag = new boolean[2 * n];</span><br><span class="line">	LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">	dfs(result, 0, cols, main_diag, anti_diag, n);</span><br><span class="line">	return resultList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(LinkedList&lt;Integer&gt; result, int row, boolean[] cols, boolean[] main_diag, boolean[] anti_diag, int n) &#123;</span><br><span class="line">	if (row == n) &#123;</span><br><span class="line">		List&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">		for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">			StringBuilder sb = new StringBuilder();</span><br><span class="line">			for (int y = 0; y &lt; n; ++y)</span><br><span class="line">				sb.append(result.get(x) == y ? &quot;Q&quot; : &quot;.&quot;);</span><br><span class="line">			list.add(sb.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		resultList.add(list);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">		if (cols[i] || main_diag[row + i] || anti_diag[row - i + n])</span><br><span class="line">			continue;</span><br><span class="line">		result.add(i);</span><br><span class="line">		cols[i] = true;</span><br><span class="line">		main_diag[row + i] = true;</span><br><span class="line">		anti_diag[row - i + n] = true;</span><br><span class="line">		dfs(result, row + 1, cols, main_diag, anti_diag, n);</span><br><span class="line">		result.removeLast();</span><br><span class="line">		cols[i] = false;</span><br><span class="line">		main_diag[row + i] = false;</span><br><span class="line">		anti_diag[row - i + n] = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/data/java-recommended-books/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/data/java-recommended-books/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- TOC -->

<ul>
<li><a href="#java">Java</a><ul>
<li><a href="#基础">基础</a></li>
<li><a href="#并发">并发</a></li>
<li><a href="#jvm">JVM</a></li>
<li><a href="#java8-新特性">Java8 新特性</a></li>
<li><a href="#代码优化">代码优化</a></li>
</ul>
</li>
<li><a href="#网络">网络</a></li>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#数据结构与算法">数据结构与算法</a></li>
<li><a href="#数据库">数据库</a></li>
<li><a href="#系统设计">系统设计</a><ul>
<li><a href="#设计模式">设计模式</a></li>
<li><a href="#常用框架">常用框架</a></li>
<li><a href="#网站架构">网站架构</a></li>
<li><a href="#软件底层">软件底层</a></li>
</ul>
</li>
<li><a href="#其他">其他</a></li>
</ul>
<!-- /TOC -->
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a>(推荐，豆瓣评分 8.7，1.0K+人评价)：  可以说是我的 Java 启蒙书籍了，特别适合新手读当然也适合我们用来温故 Java 知识点。</li>
<li><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java 核心技术卷 1+卷 2》</a>（推荐）: 很棒的两本书，建议有点 Java 基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点，是两本适合放在自己身边的好书。</li>
<li><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA 网络编程 第 4 版》</a>：  可以系统的学习一下网络的一些概念以及网络编程在 Java 中的使用。</li>
<li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java 编程思想 (第 4 版)》</a>（推荐，豆瓣评分 9.1，3.2K+人评价）：大部分人称之为Java领域的圣经，但我不推荐初学者阅读，有点劝退的味道。稍微有点基础后阅读更好。</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li><a href="https://book.douban.com/subject/30351286/" target="_blank" rel="noopener">《Java 并发编程之美》</a> （推荐）：2018 年 10 月出版的一本书，个人感觉非常不错，对每个知识点的讲解都很棒。</li>
<li><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java 并发编程的艺术》</a>（推荐，豆瓣评分 7.2，0.2K+人评价）： 这本书不是很适合作为 Java 并发入门书籍，需要具备一定的 JVM 基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</li>
<li><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战 Java 高并发程序设计》</a>（推荐,豆瓣评分 8.3）： 书的质量没的说，推荐大家好好看一下。</li>
<li><a href="https://book.douban.com/subject/30255689/" target="_blank" rel="noopener">《Java 高并发编程详解》</a>（豆瓣评分 7.6）： 2018 年 6 月出版的一本书，内容很详细，但可能又有点过于啰嗦，不过这只是我的感觉。</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机（第 2 版）周志明》</a>（推荐，豆瓣评分 8.9，1.0K+人评价）：建议多刷几遍，书中的所有知识点可以通过 JAVA 运行时区域和 JAVA 的内存模型与线程两个大模块罗列完全。 </li>
<li><a href="https://book.douban.com/subject/26354292/" target="_blank" rel="noopener">《实战 JAVA 虚拟机》</a>（推荐，豆瓣评分 8.0，1.0K+人评价）：作为入门的了解 Java 虚拟机的知识还是不错的。</li>
</ul>
<h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><ul>
<li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java 8 实战》</a> （推荐，豆瓣评分 9.2 ）：面向 Java 8 的技能升级，包括 Lambdas、流和函数式编程特性。实战系列的一贯风格让自己快速上手应用起来。Java 8 支持的 Lambda 是精简表达在语法上提供的支持。Java 8 提供了 Stream，学习和使用可以建立流式编程的认知。</li>
<li><a href="https://book.douban.com/subject/26556574/" target="_blank" rel="noopener">《Java 8 编程参考官方教程》</a> （推荐，豆瓣评分 9.2）：也还不错吧。</li>
</ul>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a>（推荐）：豆瓣 9.1 分，重构书籍的开山鼻祖。</li>
<li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a>（推荐，豆瓣评分 9.0，1.4K+人评价）：本书介绍了在 Java 编程中 78 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对 Java 平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</li>
<li><a href="https://book.douban.com/subject/5442024/" target="_blank" rel="noopener">《代码整洁之道》</a>（推荐，豆瓣评分 9.1）：虽然是用 Java 语言作为例子，全篇都是在阐述 Java 面向对象的思想，但是其中大部分内容其它语言也能应用到。</li>
<li><strong>阿里巴巴 Java 开发手册（详尽版）</strong> <a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">https://github.com/alibaba/p3c/blob/master/阿里巴巴 Java 开发手册（详尽版）.pdf</a></li>
<li><strong>Google Java 编程风格指南：</strong> <a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://www.hawstein.com/posts/google-java-style.html</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解 HTTP》</a>（推荐,豆瓣评分 8.1 , 1.6K+人评价）： 讲漫画一样的讲 HTTP，很有意思，不会觉得枯燥，大概也涵盖也 HTTP 常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究 HTTP 相关知识的话，读这本书的话应该来说就差不多了。</li>
<li><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a> （推荐,豆瓣评分 8.6）:如果要全面了解 HTTP 非此书不可！</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜》</a>（推荐，，豆瓣评分 9.1，0.3K+人评价）：本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。全书分为 5 个部分：第一部分着重说明 Linux 的起源及功能，如何规划和安装 Linux 主机；第二部分介绍 Linux 的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell 和管理系统的好帮手 shell 脚本，另外还介绍了文字编辑器 vi 和 vim 的使用方法；第四部分介绍了对于系统安全非常重要的 Linux 账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员 (root) 的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul>
<li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a>（推荐，豆瓣评分 7.9 , 1K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li>
<li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析：C 语言描述》</a>（推荐，豆瓣评分 8.9，1.6K+人评价）:本书是《Data Structures and Algorithm Analysis in C》一书第 2 版的简体中译本。原书曾被评为 20 世纪顶尖的 30 部计算机著作之一，作者 Mark Allen Weiss 在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界 500 余所大学用作教材。</li>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（推荐，豆瓣评分 8.4，0.6K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：Java 语言描述，算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。书的内容非常多，可以说是 Java 程序员的必备书籍之一了。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：mysql 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</li>
<li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis 实战》</a>：如果你想了解 Redis 的一些概念性知识的话，这本书真的非常不错。</li>
<li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a>（推荐，豆瓣评分 8.5，0.5K+人评价）：也还行吧！</li>
<li><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="noopener">《MySQL 技术内幕-InnoDB 存储引擎》</a>（推荐，豆瓣评分 8.7）：了解 InnoDB 存储引擎底层原理必备的一本书，比较深入。</li>
</ul>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式 : 可复用面向对象软件的基础》 </a> （推荐，豆瓣评分 9.1）：设计模式的经典！</li>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式（中文版）》</a> （推荐，豆瓣评分 9.2）：相当赞的一本设计模式入门书籍。用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更（对的，连需求变更都考虑到了！），并以此逐步推导出良好的设计模式解决办法。</li>
</ul>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul>
<li><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析 Java Web 技术内幕》</a>：  感觉还行，涉及的东西也蛮多。</li>
<li><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty 实战》</a>（推荐，豆瓣评分 7.8，92 人评价）：内容很细，如果想学 Netty 的话，推荐阅读这本书！</li>
<li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从 Paxos 到 Zookeeper》</a>（推荐，豆瓣评分 7.8，0.3K 人评价）：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了 Paxos 和 ZAB 协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解 ZooKeeper，并更好地使用和运维 ZooKeeper。</li>
<li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring 实战（第 4 版）》</a>（推荐，豆瓣评分 8.3，0.3K+人评价）：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于 Spring 的新华字典，只有一些基本概念的介绍和示例，涵盖了 Spring 的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习 Spring，这才刚刚开始”。</li>
<li><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ 实战指南》</a>：《RabbitMQ 实战指南》从消息中间件的概念和 RabbitMQ 的历史切入，主要阐述 RabbitMQ 的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝 RabbitMQ 的使用，这本书是你最好的选择；如果你想深入 RabbitMQ 的原理，这本书也是你最好的选择；总之，如果你想玩转 RabbitMQ，这本书一定是最值得看的书之一</li>
<li><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud 微服务实战》</a>：从时下流行的微服务架构概念出发，详细介绍了 Spring Cloud 针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud 微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li>
<li><a href="https://book.douban.com/subject/26780404/" target="_blank" rel="noopener">《第一本 Docker 书》</a>：Docker 入门书籍！</li>
</ul>
<h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul>
<li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a>（推荐）:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java 面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li>
<li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a>（推荐）：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li>
</ul>
<h3 id="软件底层"><a href="#软件底层" class="headerlink" title="软件底层"></a>软件底层</h3><ul>
<li><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析 Tomcat》</a>（推荐，豆瓣评分 8.4，0.2K+人评价）：本书深入剖析 Tomcat 4 和 Tomcat 5 中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发 Tomcat 组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li>
<li><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">《深入理解 Nginx（第 2 版）》</a>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://read.douban.com/ebook/387525/?dcs=subject-rec&dcm=douban&dct=2243615" target="_blank" rel="noopener">《黑客与画家》</a>：这本书是硅谷创业之父，Y Combinator 创始人 Paul Graham 的文集。之所以叫这个名字，是因为作者认为黑客（并非负面的那个意思）与画家有着极大的相似性，他们都是在创造，而不是完成某个任务。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/docs/HomePage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/docs/HomePage/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:47:16" itemprop="dateCreated datePublished" datetime="2019-07-14T22:47:16+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>点击订阅<a href="https://xiaozhuanlan.com/javainterview?rel=javaguide" target="_blank" rel="noopener">Java面试进阶指南</a>(专为Java面试方向准备)。<a href="https://shimo.im/./9BJjNsNg7S4dCnz3/" target="_blank" rel="noopener">为什么要弄这个专栏?</a></p>
<h1 align="center">Java 学习/面试指南</h1>
<p align="center">
<a href="https://github.com/Snailclimb/JavaGuide" target="_blank">
    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/logo - 副本.png" width>
</a>

</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#java">Java</a><ul>
<li><a href="#基础">基础</a></li>
<li><a href="#容器">容器</a></li>
<li><a href="#并发">并发</a></li>
<li><a href="#jvm">JVM</a></li>
<li><a href="#io">I/O</a></li>
<li><a href="#java-8">Java 8</a></li>
<li><a href="#编程规范">编程规范</a></li>
</ul>
</li>
<li><a href="#网络">网络</a></li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux相关">Linux相关</a></li>
</ul>
</li>
<li><a href="#数据结构与算法">数据结构与算法</a><ul>
<li><a href="#数据结构">数据结构</a></li>
<li><a href="#算法">算法</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#redis">Redis</a></li>
</ul>
</li>
<li><a href="#系统设计">系统设计</a><ul>
<li><a href="#设计模式">设计模式(工厂模式、单例模式 … )</a></li>
<li><a href="#常用框架">常用框架(Spring、Zookeeper … )</a></li>
<li><a href="#数据通信">数据通信(消息队列、Dubbo … )</a></li>
<li><a href="#网站架构">网站架构</a></li>
</ul>
</li>
<li><a href="#面试指南">面试指南</a><ul>
<li><a href="#备战面试">备战面试</a></li>
<li><a href="#常见面试题总结">常见面试题总结</a></li>
<li><a href="#面经">面经</a></li>
</ul>
</li>
<li><a href="#工具">工具</a><ul>
<li><a href="#git">Git</a></li>
<li><a href="#Docker">Docker</a></li>
</ul>
</li>
<li><a href="#资料">资料</a><ul>
<li><a href="#书单">书单</a></li>
<li><a href="#Github榜单">Github榜单</a></li>
</ul>
</li>
<li><a href="#待办">待办</a></li>
<li><a href="#说明">说明</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><a href="java/Java基础知识.md">Java 基础知识回顾</a></li>
<li><a href="java/Java疑难点.md">Java 基础知识疑难点总结</a></li>
<li><a href="java/J2EE基础知识.md">J2EE 基础知识回顾</a></li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><a href="java/collection/Java集合框架常见面试题.md">Java容器常见面试题/知识点总结</a></li>
<li><a href="java/collection/ArrayList.md">ArrayList 源码学习</a>  </li>
<li><a href="java/collection/LinkedList.md">LinkedList 源码学习</a>   </li>
<li><a href="java/collection/HashMap.md">HashMap(JDK1.8)源码学习</a>  </li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li><a href="java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md">Java 并发基础常见面试题总结</a></li>
<li><a href="java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md">Java 并发进阶常见面试题总结</a></li>
<li><a href="java/Multithread/并发容器总结.md">并发容器总结</a></li>
<li><a href="essential-content-for-interview/面试必备之乐观锁与悲观锁.md">乐观锁与悲观锁</a></li>
<li><a href="java/Multithread/Atomic.md">JUC 中的 Atomic 原子类总结</a></li>
<li><a href="java/Multithread/AQS.md">AQS 原理以及 AQS 同步组件总结</a></li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li><a href="java/jvm/Java内存区域.md">一 Java内存区域</a></li>
<li><a href="java/jvm/JVM垃圾回收.md">二 JVM垃圾回收</a></li>
<li><a href="java/jvm/JDK监控和故障处理工具总结.md">三 JDK 监控和故障处理工具</a></li>
<li><a href="java/jvm/类文件结构.md">四 类文件结构</a></li>
<li><a href="java/jvm/类加载过程.md">五 类加载过程</a></li>
<li><a href="java/jvm/类加载器.md">六 类加载器</a></li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul>
<li><a href="java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结 </a></li>
<li><a href="java/Java%20IO与NIO.md">Java IO 与 NIO系列文章</a></li>
</ul>
<h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ul>
<li><a href="java/What's%20New%20in%20JDK8/Java8Tutorial.md">Java 8 新特性总结</a></li>
<li><a href="java/What's%20New%20in%20JDK8/Java8教程推荐.md">Java 8 学习资源推荐</a></li>
</ul>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><ul>
<li><a href="java/Java编程规范.md">Java 编程规范</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><a href="network/计算机网络.md">计算机网络常见面试题</a></li>
<li><a href="network/干货：计算机网络知识总结.md">计算机网络基础知识总结</a></li>
<li><a href="network/HTTPS中的TLS.md">HTTPS中的TLS</a></li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h3><ul>
<li><a href="operating-system/后端程序员必备的Linux基础知识.md">后端程序员必备的 Linux 基础知识</a>  </li>
<li><a href="operating-system/Shell.md">Shell 编程入门</a> </li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><a href="dataStructures-algorithms/数据结构.md">数据结构知识学习与面试</a></li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><a href="dataStructures-algorithms/算法学习资源推荐.md">算法学习资源推荐</a>  </li>
<li><a href="dataStructures-algorithms/几道常见的子符串算法题.md">几道常见的字符串算法题总结 </a></li>
<li><a href="dataStructures-algorithms/几道常见的链表算法题.md">几道常见的链表算法题总结 </a>   </li>
<li><a href="dataStructures-algorithms/剑指offer部分编程题.md">剑指offer部分编程题</a></li>
<li><a href="dataStructures-algorithms/公司真题.md">公司真题</a></li>
<li><a href="dataStructures-algorithms/Backtracking-NQueens.md">回溯算法经典案例之N皇后问题</a></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li><a href="database/MySQL.md">MySQL 学习与面试</a></li>
<li><a href="database/一千行MySQL命令.md">一千行MySQL学习笔记</a></li>
<li><a href="database/MySQL高性能优化规范建议.md">MySQL高性能优化规范建议</a></li>
<li><a href="database/MySQL%20Index.md">数据库索引总结</a></li>
<li><a href="database/事务隔离级别(图文详解).md">事务隔离级别(图文详解)</a></li>
<li><a href="database/一条sql语句在mysql中如何执行的.md">一条SQL语句在MySQL中如何执行的</a></li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li><a href="database/Redis/Redis.md">Redis 总结</a></li>
<li><a href="database/Redis/Redlock分布式锁.md">Redlock分布式锁</a></li>
<li><a href="database/Redis/如何做可靠的分布式锁，Redlock真的可行么.md">如何做可靠的分布式锁，Redlock真的可行么</a></li>
</ul>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><a href="system-design/设计模式.md">设计模式系列文章</a></li>
</ul>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li><a href="system-design/framework/spring/Spring.md">Spring 学习与面试</a></li>
<li><a href="system-design/framework/spring/SpringInterviewQuestions.md">Spring 常见问题总结</a></li>
<li><a href="system-design/framework/spring/SpringBean.md">Spring中bean的作用域与生命周期</a></li>
<li><a href="system-design/framework/spring/SpringMVC-Principle.md">SpringMVC 工作原理详解</a></li>
<li><a href="system-design/framework/spring/Spring-Design-Patterns.md">Spring中都用到了那些设计模式?</a></li>
</ul>
<h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><ul>
<li><a href="system-design/framework/ZooKeeper.md">ZooKeeper 相关概念总结</a></li>
<li><a href="system-design/framework/ZooKeeper数据模型和常见命令.md">ZooKeeper 数据模型和常见命令</a></li>
</ul>
<h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><ul>
<li><a href="system-design/data-communication/summary.md">数据通信(RESTful、RPC、消息队列)相关知识点总结</a></li>
<li><a href="system-design/data-communication/dubbo.md">Dubbo 总结：关于 Dubbo 的重要知识点</a></li>
<li><a href="system-design/data-communication/message-queue.md">消息队列总结</a></li>
<li><a href="system-design/data-communication/rabbitmq.md">RabbitMQ 入门</a></li>
<li><a href="system-design/data-communication/RocketMQ-Questions.md">RocketMQ的几个简单问题与答案</a></li>
</ul>
<h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul>
<li><a href="system-design/website-architecture/分布式.md">一文读懂分布式应该学什么</a></li>
<li><a href="system-design/website-architecture/8%20张图读懂大型网站技术架构.md">8 张图读懂大型网站技术架构</a></li>
<li><a href="system-design/website-architecture/【面试精选】关于大型网站系统架构你不得不懂的10个问题.md">【面试精选】关于大型网站系统架构你不得不懂的10个问题</a></li>
</ul>
<h2 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h2><h3 id="备战面试"><a href="#备战面试" class="headerlink" title="备战面试"></a>备战面试</h3><ul>
<li><a href="essential-content-for-interview/PreparingForInterview/程序员的简历之道.md">【备战面试1】程序员的简历就该这样写</a></li>
<li><a href="essential-content-for-interview/PreparingForInterview/interviewPrepare.md">【备战面试2】初出茅庐的程序员该如何准备面试？</a></li>
<li><a href="essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow.md">【备战面试3】7个大部分程序员在面试前很关心的问题</a></li>
<li><a href="essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary.md">【备战面试4】Github上开源的Java面试/学习相关的仓库推荐</a></li>
<li><a href="essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答.md">【备战面试5】如果面试官问你“你有什么问题问我吗？”时，你该如何回答</a></li>
<li><a href="essential-content-for-interview/PreparingForInterview/美团面试常见问题总结.md">【备战面试6】美团面试常见问题总结（附详解答案）</a></li>
</ul>
<h3 id="常见面试题总结"><a href="#常见面试题总结" class="headerlink" title="常见面试题总结"></a>常见面试题总结</h3><ul>
<li><a href="essential-content-for-interview/MostCommonJavaInterviewQuestions/第一周（2018-8-7）.md">第一周（2018-8-7）</a> (为什么 Java 中只有值传递、==与equals、 hashCode与equals)</li>
<li><a href="essential-content-for-interview/MostCommonJavaInterviewQuestions/第二周(2018-8-13).md">第二周（2018-8-13）</a>(String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？、什么是反射机制？反射机制的应用场景有哪些？……)</li>
<li><a href="java/collection/Java集合框架常见面试题.md">第三周（2018-08-22）</a> （Arraylist 与 LinkedList 异同、ArrayList 与 Vector 区别、HashMap的底层实现、HashMap 和 Hashtable 的区别、HashMap 的长度为什么是2的幂次方、HashSet 和 HashMap 区别、ConcurrentHashMap 和 Hashtable 的区别、ConcurrentHashMap线程安全的具体实现方式/底层具体实现、集合框架底层数据结构总结）</li>
<li><a href="essential-content-for-interview/MostCommonJavaInterviewQuestions/第四周(2018-8-30).md">第四周(2018-8-30).md</a> （主要内容是几道面试常问的多线程基础题。）</li>
</ul>
<h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><ul>
<li><a href="essential-content-for-interview/BATJrealInterviewExperience/5面阿里,终获offer.md">5面阿里,终获offer(2018年秋招)</a></li>
<li><a href="essential-content-for-interview/BATJrealInterviewExperience/蚂蚁金服实习生面经总结(已拿口头offer).md">蚂蚁金服2019实习生面经总结(已拿口头offer)</a></li>
<li><a href="essential-content-for-interview/BATJrealInterviewExperience/2019alipay-pinduoduo-toutiao.md">2019年蚂蚁金服、头条、拼多多的面试总结</a></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li><a href="tools/Git.md">Git入门</a></li>
</ul>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul>
<li><a href="tools/Docker.md">Docker 入门</a></li>
<li><a href="tools/Docker-Image.md">一文搞懂 Docker 镜像的常用操作！</a></li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><ul>
<li><a href="data/java-recommended-books.md">Java程序员必备书单</a></li>
</ul>
<h3 id="Github榜单"><a href="#Github榜单" class="headerlink" title="Github榜单"></a>Github榜单</h3><ul>
<li><a href="github-trending/JavaGithubTrending.md">Java 项目月榜单</a></li>
</ul>
<hr>
<h2 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h2><ul>
<li><input checked disabled type="checkbox"> <a href="./java/What's%20New%20in%20JDK8/Java8Tutorial.md">Java 8 新特性总结</a></li>
<li><input checked disabled type="checkbox"> <a href="./java/What's%20New%20in%20JDK8/Java8教程推荐.md">Java 8 新特性详解</a></li>
<li><input disabled type="checkbox"> Java 多线程类别知识重构(—正在进行中—)</li>
<li><input checked disabled type="checkbox"> <a href="./java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结 </a></li>
<li><input disabled type="checkbox"> Netty 总结(—正在进行中—)</li>
<li><input disabled type="checkbox"> 数据结构总结重构(—正在进行中—)</li>
</ul>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>添加我的微信备注“Github”,回复关键字 <strong>“加群”</strong> 即可入群。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/JavaGuide.jpg" alt="我的微信"></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><ul>
<li>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</li>
<li>由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</li>
<li>一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </li>
</ul>
<p align="center">
<img src="https://user-gold-cdn.xitu.io/2018/11/28/167598cd2e17b8ec?w=258&h=258&f=jpeg&s=27334" width>
</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/javaGuide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="syf">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏有福的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/javaGuide/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-14 22:41:39" itemprop="dateCreated datePublished" datetime="2019-07-14T22:41:39+08:00">2019-07-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#java">Java</a><ul>
<li><a href="#基础">基础</a></li>
<li><a href="#容器">容器</a></li>
<li><a href="#并发">并发</a></li>
<li><a href="#jvm">JVM</a></li>
<li><a href="#io">I/O</a></li>
<li><a href="#java-8">Java 8</a></li>
<li><a href="#编程规范">编程规范</a></li>
</ul>
</li>
<li><a href="#网络">网络</a></li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#linux相关">Linux相关</a></li>
</ul>
</li>
<li><a href="#数据结构与算法">数据结构与算法</a><ul>
<li><a href="#数据结构">数据结构</a></li>
<li><a href="#算法">算法</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#redis">Redis</a></li>
</ul>
</li>
<li><a href="#系统设计">系统设计</a><ul>
<li><a href="#设计模式">设计模式(工厂模式、单例模式 … )</a></li>
<li><a href="#常用框架">常用框架(Spring、Zookeeper … )</a></li>
<li><a href="#数据通信">数据通信(消息队列、Dubbo … )</a></li>
<li><a href="#网站架构">网站架构</a></li>
</ul>
</li>
<li><a href="#面试指南">面试指南</a><ul>
<li><a href="#备战面试">备战面试</a></li>
<li><a href="#常见面试题总结">常见面试题总结</a></li>
<li><a href="#面经">面经</a></li>
</ul>
</li>
<li><a href="#工具">工具</a><ul>
<li><a href="#git">Git</a></li>
<li><a href="#Docker">Docker</a></li>
</ul>
</li>
<li><a href="#资料">资料</a><ul>
<li><a href="#书单">书单</a></li>
<li><a href="#Github榜单">Github榜单</a></li>
</ul>
</li>
<li><a href="#待办">待办</a></li>
<li><a href="#说明">说明</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><a href="docs/java/Java基础知识.md">Java 基础知识回顾</a></li>
<li><a href="docs/java/Java疑难点.md">Java 基础知识疑难点/易错点</a></li>
<li><a href="docs/java/Java程序设计题.md">一些重要的Java程序设计题</a></li>
<li><a href="docs/java/J2EE基础知识.md">J2EE 基础知识回顾</a></li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><a href="docs/java/collection/Java集合框架常见面试题.md">Java容器常见面试题/知识点总结</a></li>
<li><a href="docs/java/collection/ArrayList.md">ArrayList 源码学习</a>  </li>
<li><a href="docs/java/collection/LinkedList.md">LinkedList 源码学习</a>   </li>
<li><a href="docs/java/collection/HashMap.md">HashMap(JDK1.8)源码学习</a>  </li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li><a href="docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md">Java 并发基础常见面试题总结</a></li>
<li><a href="docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md">Java 并发进阶常见面试题总结</a></li>
<li><a href="docs/java/Multithread/并发容器总结.md">并发容器总结</a></li>
<li><a href="docs/essential-content-for-interview/面试必备之乐观锁与悲观锁.md">乐观锁与悲观锁</a></li>
<li><a href="docs/java/Multithread/Atomic.md">JUC 中的 Atomic 原子类总结</a></li>
<li><a href="docs/java/Multithread/AQS.md">AQS 原理以及 AQS 同步组件总结</a></li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li><a href="docs/java/jvm/Java内存区域.md">一 Java内存区域</a></li>
<li><a href="docs/java/jvm/JVM垃圾回收.md">二 JVM垃圾回收</a></li>
<li><a href="docs/java/jvm/JDK监控和故障处理工具总结.md">三 JDK 监控和故障处理工具</a></li>
<li><a href="docs/java/jvm/类文件结构.md">四 类文件结构</a></li>
<li><a href="docs/java/jvm/类加载过程.md">五 类加载过程</a></li>
<li><a href="docs/java/jvm/类加载器.md">六 类加载器</a></li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul>
<li><a href="docs/java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结 </a></li>
<li><a href="docs/java/Java%20IO与NIO.md">Java IO 与 NIO系列文章</a></li>
</ul>
<h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ul>
<li><a href="docs/java/What's%20New%20in%20JDK8/Java8Tutorial.md">Java 8 新特性总结</a></li>
<li><a href="docs/java/What's%20New%20in%20JDK8/Java8教程推荐.md">Java 8 学习资源推荐</a></li>
</ul>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><ul>
<li><a href="docs/java/Java编程规范.md">Java 编程规范</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><a href="docs/network/计算机网络.md">计算机网络常见面试题</a></li>
<li><a href="docs/network/干货：计算机网络知识总结.md">计算机网络基础知识总结</a></li>
<li><a href="docs/network/HTTPS中的TLS.md">HTTPS中的TLS</a></li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h3><ul>
<li><a href="docs/operating-system/后端程序员必备的Linux基础知识.md">后端程序员必备的 Linux 基础知识</a>  </li>
<li><a href="docs/operating-system/Shell.md">Shell 编程入门</a> </li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><a href="docs/dataStructures-algorithms/数据结构.md">数据结构知识学习与面试</a></li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><a href="docs/dataStructures-algorithms/算法学习资源推荐.md">算法学习资源推荐</a>  </li>
<li><a href="docs/dataStructures-algorithms/几道常见的子符串算法题.md">几道常见的字符串算法题总结 </a></li>
<li><a href="docs/dataStructures-algorithms/几道常见的链表算法题.md">几道常见的链表算法题总结 </a>   </li>
<li><a href="docs/dataStructures-algorithms/剑指offer部分编程题.md">剑指offer部分编程题</a></li>
<li><a href="docs/dataStructures-algorithms/公司真题.md">公司真题</a></li>
<li><a href="docs/dataStructures-algorithms/Backtracking-NQueens.md">回溯算法经典案例之N皇后问题</a></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li><a href="docs/database/MySQL.md">MySQL 学习与面试</a></li>
<li><a href="docs/database/一千行MySQL命令.md">一千行MySQL学习笔记</a></li>
<li><a href="docs/database/MySQL高性能优化规范建议.md">MySQL高性能优化规范建议</a></li>
<li><a href="docs/database/MySQL%20Index.md">数据库索引总结</a></li>
<li><a href="docs/database/事务隔离级别(图文详解).md">事务隔离级别(图文详解)</a></li>
<li><a href="docs/database/一条sql语句在mysql中如何执行的.md">一条SQL语句在MySQL中如何执行的</a></li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li><a href="docs/database/Redis/Redis.md">Redis 总结</a></li>
<li><a href="docs/database/Redis/Redlock分布式锁.md">Redlock分布式锁</a></li>
<li><a href="docs/database/Redis/如何做可靠的分布式锁，Redlock真的可行么.md">如何做可靠的分布式锁，Redlock真的可行么</a></li>
</ul>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><a href="docs/system-design/设计模式.md">设计模式系列文章</a></li>
</ul>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li><a href="docs/system-design/framework/spring/Spring.md">Spring 学习与面试</a></li>
<li><a href="docs/system-design/framework/spring/SpringInterviewQuestions.md">Spring 常见问题总结</a></li>
<li><a href="docs/system-design/framework/spring/SpringBean.md">Spring中bean的作用域与生命周期</a></li>
<li><a href="docs/system-design/framework/spring/SpringMVC-Principle.md">SpringMVC 工作原理详解</a></li>
<li><a href="docs/system-design/framework/spring/Spring-Design-Patterns.md">Spring中都用到了那些设计模式?</a></li>
</ul>
<h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><ul>
<li><a href="docs/system-design/framework/ZooKeeper.md">ZooKeeper 相关概念总结</a></li>
<li><a href="docs/system-design/framework/ZooKeeper数据模型和常见命令.md">ZooKeeper 数据模型和常见命令</a></li>
</ul>
<h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><ul>
<li><a href="docs/system-design/data-communication/summary.md">数据通信(RESTful、RPC、消息队列)相关知识点总结</a></li>
<li><a href="docs/system-design/data-communication/dubbo.md">Dubbo 总结：关于 Dubbo 的重要知识点</a></li>
<li><a href="docs/system-design/data-communication/message-queue.md">消息队列总结</a></li>
<li><a href="docs/system-design/data-communication/rabbitmq.md">RabbitMQ 入门</a></li>
<li><a href="docs/system-design/data-communication/RocketMQ-Questions.md">RocketMQ的几个简单问题与答案</a></li>
</ul>
<h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul>
<li><a href="docs/system-design/website-architecture/分布式.md">一文读懂分布式应该学什么</a></li>
<li><a href="docs/system-design/website-architecture/8%20张图读懂大型网站技术架构.md">8 张图读懂大型网站技术架构</a></li>
<li><a href="docs/system-design/website-architecture/【面试精选】关于大型网站系统架构你不得不懂的10个问题.md">【面试精选】关于大型网站系统架构你不得不懂的10个问题</a></li>
</ul>
<h2 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h2><h3 id="备战面试"><a href="#备战面试" class="headerlink" title="备战面试"></a>备战面试</h3><ul>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/程序员的简历之道.md">【备战面试1】程序员的简历就该这样写</a></li>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/interviewPrepare.md">【备战面试2】初出茅庐的程序员该如何准备面试？</a></li>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/JavaProgrammerNeedKnow.md">【备战面试3】7个大部分程序员在面试前很关心的问题</a></li>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/JavaInterviewLibrary.md">【备战面试4】Github上开源的Java面试/学习相关的仓库推荐</a></li>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/如果面试官问你“你有什么问题问我吗？”时，你该如何回答.md">【备战面试5】如果面试官问你“你有什么问题问我吗？”时，你该如何回答</a></li>
<li><a href="docs/essential-content-for-interview/PreparingForInterview/美团面试常见问题总结.md">【备战面试6】美团面试常见问题总结（附详解答案）</a></li>
</ul>
<h3 id="常见面试题总结"><a href="#常见面试题总结" class="headerlink" title="常见面试题总结"></a>常见面试题总结</h3><ul>
<li><a href="docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第一周（2018-8-7）.md">第一周（2018-8-7）</a> (为什么 Java 中只有值传递、==与equals、 hashCode与equals)</li>
<li><a href="docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第二周(2018-8-13).md">第二周（2018-8-13）</a>(String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？、什么是反射机制？反射机制的应用场景有哪些？……)</li>
<li><a href="docs/java/collection/Java集合框架常见面试题.md">第三周（2018-08-22）</a> （Arraylist 与 LinkedList 异同、ArrayList 与 Vector 区别、HashMap的底层实现、HashMap 和 Hashtable 的区别、HashMap 的长度为什么是2的幂次方、HashSet 和 HashMap 区别、ConcurrentHashMap 和 Hashtable 的区别、ConcurrentHashMap线程安全的具体实现方式/底层具体实现、集合框架底层数据结构总结）</li>
<li><a href="docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/第四周(2018-8-30).md">第四周(2018-8-30).md</a> （主要内容是几道面试常问的多线程基础题。）</li>
</ul>
<h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><ul>
<li><a href="docs/essential-content-for-interview/BATJrealInterviewExperience/5面阿里,终获offer.md">5面阿里,终获offer(2018年秋招)</a></li>
<li><a href="docs/essential-content-for-interview/BATJrealInterviewExperience/蚂蚁金服实习生面经总结(已拿口头offer).md">蚂蚁金服2019实习生面经总结(已拿口头offer)</a></li>
<li><a href="docs/essential-content-for-interview/BATJrealInterviewExperience/2019alipay-pinduoduo-toutiao.md">2019年蚂蚁金服、头条、拼多多的面试总结</a></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li><a href="docs/tools/Git.md">Git入门</a></li>
</ul>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul>
<li><a href="docs/tools/Docker.md">Docker 入门</a></li>
<li><a href="docs/tools/Docker-Image.md">一文搞懂 Docker 镜像的常用操作！</a></li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><ul>
<li><a href="docs/data/java-recommended-books.md">Java程序员必备书单</a></li>
</ul>
<h3 id="Github榜单"><a href="#Github榜单" class="headerlink" title="Github榜单"></a>Github榜单</h3><ul>
<li><a href="docs/github-trending/JavaGithubTrending.md">Java 项目月榜单</a></li>
</ul>
<hr>
<h2 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h2><ul>
<li><input disabled type="checkbox"> Java 多线程类别知识重构(—正在进行中—)</li>
<li><input disabled type="checkbox"> Netty 总结(—正在进行中—)</li>
<li><input disabled type="checkbox"> 数据结构总结重构(—正在进行中—)</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><strong>对于 Java 初学者来说：</strong> 本文档倾向于给你提供一个比较详细的学习路径，让你对于Java整体的知识体系有一个初步认识。另外，本文的一些文章<br>也是你学习和复习 Java 知识不错的实践；</li>
<li><strong>对于非 Java 初学者来说：</strong> 本文档更适合回顾知识，准备面试，搞清面试应该把重心放在那些问题上。要搞清楚这个道理：提前知道那些面试常见，不是为了背下来应付面试，而是为了让你可以更有针对的学习重点。</li>
</ul>
<p>Markdown 格式参考：<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Github Markdown格式</a>，表情素材来自：<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">EMOJI CHEAT SHEET</a>。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">syf</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">102</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syf</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
